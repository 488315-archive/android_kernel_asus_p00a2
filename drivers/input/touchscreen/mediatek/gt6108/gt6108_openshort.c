/* drivers/input/touchscreen/gt9xx_shorttp.c
 *
 * 2010 - 2012 Goodix Technology.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be a reference
 * to you, when you are integrating the GOODiX's CTP IC into your system,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * Version:1.0
 * Author: meta@goodix.com
 * Accomplished Date:2012/10/20
 * Revision record:
 *
 */

#include <gt6108_openshort.h>
#include <linux/slab.h> // add by leo for kzalloc
#include <linux/proc_fs.h> // add by leo for proc
#include <linux/debugfs.h> // add by leo for proc


#define GTP_TEST_INFO_MAX		1460

// short test
#define GTP_SHORT_GND
#define GTP_VDD         33      // 3.3V

// open test
u16 max_limit_value = 2000; // screen max limit
u16 min_limit_value = 1200;  // screen min limit
u16 max_limit_key = 1631;       // key_val max limit
u16 min_limit_key = 625;        // key_val min limit


extern void gtp_irq_disable(struct goodix_ts_data *ts);
extern void gtp_irq_enable(struct goodix_ts_data *ts);
extern void gtp_reset_guitar(struct i2c_client*, s32);
extern s8 gtp_enter_sleep(struct goodix_ts_data * ts);
extern s8 gtp_wakeup_sleep(struct goodix_ts_data * ts);
extern s32 gtp_i2c_read(struct i2c_client *, u8 *, s32);
extern s32 gtp_i2c_write(struct i2c_client *, u8 *, s32);
extern s32 gup_enter_update_mode(struct i2c_client *);
extern s32 gup_leave_update_mode(void);
extern s32 gtp_send_cfg(struct i2c_client *client);
extern s32 gtp_read_version(struct i2c_client *client, u16* version);

extern s8 gtp_enter_sleep(struct goodix_ts_data * ts);
extern s8 gtp_wakeup_sleep(struct goodix_ts_data * ts);

extern struct i2c_client * i2c_connect_client;
extern u8 config[GTP_ADDR_LENGTH + GTP_CONFIG_MAX_LENGTH];

u8  gt9xx_drv_num = MAX_DRIVER_NUM;	// default driver and sensor number
u8  gt9xx_sen_num = MAX_SENSOR_NUM;
u16 gt9xx_pixel_cnt = MAX_DRIVER_NUM * MAX_SENSOR_NUM;
u16 gt9xx_sc_pxl_cnt = MAX_DRIVER_NUM * MAX_SENSOR_NUM;
u16 gt6108_channel_cnt = 27*40; // add by leo for get raw data
struct gt9xx_short_info *short_sum;

#if GTP_HAVE_TOUCH_KEY
u8 gt9xx_sc_drv_num;
u8 key_is_isolated;	// 0: no, 1: yes
u8 key_iso_pos[5];
#endif

struct kobject *goodix_debug_kobj;
static s32 sample_set_num = 16;
static u32 default_test_types = _MAX_TEST | _MIN_TEST | _KEY_MAX_TEST | _KEY_MIN_TEST;
static u8  rslt_buf_idx = 0;
static s32 *test_rslt_buf;
static struct gt9xx_open_info *touchpad_sum;

#define _MAX_ERROR_NUM      (sample_set_num	* 1 / 10)
//#define _MAX_ERROR_NUM      0

static char *result_lines[GTP_TEST_INFO_MAX];
static char tmp_info_line[GTP_TEST_INFO_MAX];
static u8 RsltIndex;

// add by leo for dump raw data ++
u16 gt6108_raw_data[MAX_DRIVER_NUM * MAX_SENSOR_NUM] = {0};
u16 gt6108_acc_data[MAX_DRIVER_NUM * MAX_SENSOR_NUM] = {0};

#define TEST_CONFIG_FILE_PATH	"/data/gt6108_test_config.ini"
#define	GT6108_PROC_TEST_FILE	"gt6108_test"
#define	GT6108_PROC_DIAG_FILE	"gt6108_diag"

static struct proc_dir_entry *gt6108_proc_test_file;
static struct proc_dir_entry *gt6108_proc_diag_file;

void gt6108_create_proc_test_file(void);
void gt6108_remove_proc_test_file(void);
void gt6108_create_proc_diag_file(void);
void gt6108_remove_proc_diag_file(void);
// add by leo for dump raw data --

static void append_info_line(void)
{
	if (strlen(tmp_info_line) != 0)
	{
		result_lines[RsltIndex] = (char *)kzalloc(strlen(tmp_info_line)+1, GFP_KERNEL);
		memcpy(result_lines[RsltIndex], tmp_info_line, strlen(tmp_info_line));
	}
	if (RsltIndex != (GTP_TEST_INFO_MAX-1))
		++RsltIndex;
	else
	{
		kfree(result_lines[RsltIndex]);
	}
	return;
}

#define SET_INFO_SHORT_INFO(fmt, args...)       do{ memset(tmp_info_line, '\0', 80);\
		sprintf(tmp_info_line, " "fmt, ##args);\
		printk(fmt, ##args);\
		append_info_line();} while(0)

#define SET_INFO_LINE_INFO(fmt, args...)       do{ memset(tmp_info_line, '\0', 80);\
		sprintf(tmp_info_line, "<Sysfs-INFO>"fmt"\n", ##args);\
		GTP_INFO(fmt, ##args);\
		append_info_line();} while(0)

#define SET_INFO_LINE_ERR(fmt, args...)        do { memset(tmp_info_line, '\0', 80);\
		sprintf(tmp_info_line, "<Sysfs-ERROR>"fmt"\n", ##args);\
		GTP_ERROR(fmt, ##args);\
		append_info_line();}while(0)


static u8 cfg_drv_order[MAX_DRIVER_NUM];
static u8 cfg_sen_order[MAX_SENSOR_NUM];

/*
 * Initialize cfg_drv_order and cfg_sen_order, which is used for report short channels
 *
 */

// add by leo for dynamic change limit value ++
struct gt9xx_tp_raw_acc_info
{
	u16 node_number;
	u16 max_rawdata;
	u16 min_rawdata;
	u16 acc_data;
};
static struct gt9xx_tp_raw_acc_info *gt6108_raw_acc_spec = NULL;
#if 0
//AUO + GIS Spec B
static u16 GuitarTestPlatformINI_GIS[TOTAL_PIXEL_NUM*4]=
{
	0,2700,1200,230,1,2700,1200,230,2,2700,1200,230,3,2700,1200,230,4,2700,1200,230,5,2700,1200,230,6,2700,1200,230,7,2700,1200,230,8,2700,1200,230,9,2700,1200,230,10,2700,1200,230,11,2700,1200,230,12,2700,1200,230,13,2700,1200,230,14,2700,1200,230,15,2700,1200,230,16,2700,1200,230,17,2700,1200,230,18,2700,1200,230,19,2700,1200,230,20,2700,1200,230,21,2700,1200,230,22,2700,1200,230,23,2700,1200,230,24,2700,1200,230,25,2700,1200,230,26,2700,1200,230,27,2700,1200,230,28,2700,1200,230,29,2700,1200,230,30,2700,1200,230,31,2700,1200,230,32,2700,1200,230,33,2700,1200,230,34,2700,1200,230,35,2700,1200,230,36,2700,1200,230,37,2700,1200,230,38,2700,1200,230,39,2700,1200,230,40,2700,1200,230,41,2700,1200,230,42,2700,1200,230,43,2700,1200,230,44,2700,1200,230,45,2700,1200,230,46,2700,1200,230,47,2700,1200,230,48,2700,1200,230,49,2700,1200,230,50,2700,1200,230,51,2700,1200,230,52,2700,1200,230,53,2700,1200,230,54,2700,1200,230,55,2700,1200,230,56,2700,1200,230,57,2700,1200,230,58,2700,1200,230,59,2700,1200,230,60,2700,1200,230,61,2700,1200,230,62,2700,1200,230,63,2700,1200,230,64,2700,1200,230,65,2700,1200,230,66,2700,1200,230,67,2700,1200,230,68,2700,1200,230,69,2700,1200,230,70,2700,1200,230,71,2700,1200,230,72,2700,1200,230,73,2700,1200,230,74,2700,1200,230,75,2700,1200,230,76,2700,1200,230,77,2700,1200,230,78,2700,1200,230,79,2700,1200,230,80,2700,1200,230,81,2700,1200,230,82,2700,1200,230,83,2700,1200,230,84,2700,1200,230,85,2700,1200,230,86,2700,1200,230,87,2700,1200,230,88,2700,1200,230,89,2700,1200,230,90,2700,1200,230,91,2700,1200,230,92,2700,1200,230,93,2700,1200,230,94,2700,1200,230,95,2700,1200,230,96,2700,1200,230,97,2700,1200,230,98,2700,1200,230,99,2700,1200,230,100,2700,1200,230,101,2700,1200,230,102,2700,1200,230,103,2700,1200,230,104,2700,1200,230,105,2700,1200,230,106,2700,1200,230,107,2700,1200,230,108,2700,1200,230,109,2700,1200,230,110,2700,1200,230,111,2700,1200,230,112,2700,1200,230,113,2700,1200,230,114,2700,1200,230,115,2700,1200,230,116,2700,1200,230,117,2700,1200,230,118,2700,1200,230,119,2700,1200,230,120,2700,1200,230,121,2700,1200,230,122,2700,1200,230,123,2700,1200,230,124,2700,1200,230,125,2700,1200,230,126,2700,1200,230,127,2700,1200,230,128,2700,1200,230,129,2700,1200,230,130,2700,1200,230,131,2700,1200,230,132,2700,1200,230,133,2700,1200,230,134,2700,1200,230,135,2700,1200,230,136,2700,1200,230,137,2700,1200,230,138,2700,1200,230,139,2700,1200,230,140,2700,1200,230,141,2700,1200,230,142,2700,1200,230,143,2700,1200,230,144,2700,1200,230,145,2700,1200,230,146,2700,1200,230,147,2700,1200,230,148,2700,1200,230,149,2700,1200,230,150,2700,1200,230,151,2700,1200,230,152,2700,1200,230,153,2700,1200,230,154,2700,1200,230,155,2700,1200,230,156,2700,1200,230,157,2700,1200,230,158,2700,1200,230,159,2700,1200,230,160,2700,1200,230,161,2700,1200,230,162,2700,1200,230,163,2700,1200,230,164,2700,1200,230,165,2700,1200,230,166,2700,1200,230,167,2700,1200,230,168,2700,1200,230,169,2700,1200,230,170,2700,1200,230,171,2700,1200,230,172,2700,1200,230,173,2700,1200,230,174,2700,1200,230,175,2700,1200,230,176,2700,1200,230,177,2700,1200,230,178,2700,1200,230,179,2700,1200,230,180,2700,1200,230,181,2700,1200,230,182,2700,1200,230,183,2700,1200,230,184,2700,1200,230,185,2700,1200,230,186,2700,1200,230,187,2700,1200,230,188,2700,1200,230,189,2700,1200,230,190,2700,1200,230,191,2700,1200,230,192,2700,1200,230,193,2700,1200,230,194,2700,1200,230,195,2700,1200,230,196,2700,1200,230,197,2700,1200,230,198,2700,1200,230,199,2700,1200,230,200,2700,1200,230,201,2700,1200,230,202,2700,1200,230,203,2700,1200,230,204,2700,1200,230,205,2700,1200,230,206,2700,1200,230,207,2700,1200,230,208,2700,1200,230,209,2700,1200,230,210,2700,1200,230,211,2700,1200,230,212,2700,1200,230,213,2700,1200,230,214,2700,1200,230,215,2700,1200,230,216,2700,1200,230,217,2700,1200,230,218,2700,1200,230,219,2700,1200,230,220,2700,1200,230,221,2700,1200,230,222,2700,1200,230,223,2700,1200,230,224,2700,1200,230,225,2700,1200,230,226,2700,1200,230,227,2700,1200,230,228,2700,1200,230,229,2700,1200,230,230,2700,1200,230,231,2700,1200,230,232,2700,1200,230,233,
	2700,1200,230,234,2700,1200,230,235,2700,1200,230,236,2700,1200,230,237,2700,1200,230,238,2700,1200,230,239,2700,1200,230,240,2700,1200,230,241,2700,1200,230,242,2700,1200,230,243,2700,1200,230,244,2700,1200,230,245,2700,1200,230,246,2700,1200,230,247,2700,1200,230,248,2700,1200,230,249,2700,1200,230,250,2700,1200,230,251,2700,1200,230,252,2700,1200,230,253,2700,1200,230,254,2700,1200,230,255,2700,1200,230,256,2700,1200,230,257,2700,1200,230,258,2700,1200,230,259,2700,1200,230,260,2700,1200,230,261,2700,1200,230,262,2700,1200,230,263,2700,1200,230,264,2700,1200,230,265,2700,1200,230,266,2700,1200,230,267,2700,1200,230,268,2700,1200,230,269,2700,1200,230,270,2700,1200,230,271,2700,1200,230,272,2700,1200,230,273,2700,1200,230,274,2700,1200,230,275,2700,1200,230,276,2700,1200,230,277,2700,1200,230,278,2700,1200,230,279,2700,1200,230,280,2700,1200,230,281,2700,1200,230,282,2700,1200,230,283,2700,1200,230,284,2700,1200,230,285,2700,1200,230,286,2700,1200,230,287,2700,1200,230,288,2700,1200,230,289,2700,1200,230,290,2700,1200,230,291,2700,1200,230,292,2700,1200,230,293,2700,1200,230,294,2700,1200,230,295,2700,1200,230,296,2700,1200,230,297,2700,1200,230,298,2700,1200,230,299,2700,1200,230,300,2700,1200,230,301,2700,1200,230,302,2700,1200,230,303,2700,1200,230,304,2700,1200,230,305,2700,1200,230,306,2700,1200,230,307,2700,1200,230,308,2700,1200,230,309,2700,1200,230,310,2700,1200,230,311,2700,1200,230,312,2700,1200,230,313,2700,1200,230,314,2700,1200,230,315,2700,1200,230,316,2700,1200,230,317,2700,1200,230,318,2700,1200,230,319,2700,1200,230,320,2700,1200,230,321,2700,1200,230,322,2700,1200,230,323,2700,1200,230,324,2700,1200,230,325,2700,1200,230,326,2700,1200,230,327,2700,1200,230,328,2700,1200,230,329,2700,1200,230,330,2700,1200,230,331,2700,1200,230,332,2700,1200,230,333,2700,1200,230,334,2700,1200,230,335,2700,1200,230,336,2700,1200,230,337,2700,1200,230,338,2700,1200,230,339,2700,1200,230,340,2700,1200,230,341,2700,1200,230,342,2700,1200,230,343,2700,1200,230,344,2700,1200,230,345,2700,1200,230,346,2700,1200,230,347,2700,1200,230,348,2700,1200,230,349,2700,1200,230,350,2700,1200,230,351,2700,1200,230,352,2700,1200,230,353,2700,1200,230,354,2700,1200,230,355,2700,1200,230,356,2700,1200,230,357,2700,1200,230,358,2700,1200,230,359,2700,1200,230,360,2700,1200,230,361,2700,1200,230,362,2700,1200,230,363,2700,1200,230,364,2700,1200,230,365,2700,1200,230,366,2700,1200,230,367,2700,1200,230,368,2700,1200,230,369,2700,1200,230,370,2700,1200,230,371,2700,1200,230,372,2700,1200,230,373,2700,1200,230,374,2700,1200,230,375,2700,1200,230,376,2700,1200,230,377,2700,1200,230,378,2700,1200,230,379,2700,1200,230,380,2700,1200,230,381,2700,1200,230,382,2700,1200,230,383,2700,1200,230,384,2700,1200,230,385,2700,1200,230,386,2700,1200,230,387,2700,1200,230,388,2700,1200,230,389,2700,1200,230,390,2700,1200,230,391,2700,1200,230,392,2700,1200,230,393,2700,1200,230,394,2700,1200,230,395,2700,1200,230,396,2700,1200,230,397,2700,1200,230,398,2700,1200,230,399,2700,1200,230,400,2700,1200,230,401,2700,1200,230,402,2700,1200,230,403,2700,1200,230,404,2700,1200,230,405,2700,1200,230,406,2700,1200,230,407,2700,1200,230,408,2700,1200,230,409,2700,1200,230,410,2700,1200,230,411,2700,1200,230,412,2700,1200,230,413,2700,1200,230,414,2700,1200,230,415,2700,1200,230,416,2700,1200,230,417,2700,1200,230,418,2700,1200,230,419,2700,1200,230,420,2700,1200,230,421,2700,1200,230,422,2700,1200,230,423,2700,1200,230,424,2700,1200,230,425,2700,1200,230,426,2700,1200,230,427,2700,1200,230,428,2700,1200,230,429,2700,1200,230,430,2700,1200,230,431,2700,1200,230,432,2700,1200,230,433,2700,1200,230,434,2700,1200,230,435,2700,1200,230,436,2700,1200,230,437,2700,1200,230,438,2700,1200,230,439,2700,1200,230,440,2700,1200,230,441,2700,1200,230,442,2700,1200,230,443,2700,1200,230,444,2700,1200,230,445,2700,1200,230,446,2700,1200,230,447,2700,1200,230,448,2700,1200,230,449,2700,1200,230,450,2700,1200,230,451,2700,1200,230,452,2700,1200,230,453,2700,1200,230,454,2700,1200,230,455,2700,1200,230,456,2700,1200,230,457,2700,1200,230,458,2700,1200,230,459,2700,1200,230,460,2700
	,1200,230,461,2700,1200,230,462,2700,1200,230,463,2700,1200,230,464,2700,1200,230,465,2700,1200,230,466,2700,1200,230,467,2700,1200,230,468,2700,1200,230,469,2700,1200,230,470,2700,1200,230,471,2700,1200,230,472,2700,1200,230,473,2700,1200,230,474,2700,1200,230,475,2700,1200,230,476,2700,1200,230,477,2700,1200,230,478,2700,1200,230,479,2700,1200,230,480,2700,1200,230,481,2700,1200,230,482,2700,1200,230,483,2700,1200,230,484,2700,1200,230,485,2700,1200,230,486,2700,1200,230,487,2700,1200,230,488,2700,1200,230,489,2700,1200,230,490,2700,1200,230,491,2700,1200,230,492,2700,1200,230,493,2700,1200,230,494,2700,1200,230,495,2700,1200,230,496,2700,1200,230,497,2700,1200,230,498,2700,1200,230,499,2700,1200,230,500,2700,1200,230,501,2700,1200,230,502,2700,1200,230,503,2700,1200,230,504,2700,1200,230,505,2700,1200,230,506,2700,1200,230,507,2700,1200,230,508,2700,1200,230,509,2700,1200,230,510,2700,1200,230,511,2700,1200,230,512,2700,1200,230,513,2700,1200,230,514,2700,1200,230,515,2700,1200,230,516,2700,1200,230,517,2700,1200,230,518,2700,1200,230,519,2700,1200,230,520,2700,1200,230,521,2700,1200,230,522,2700,1200,230,523,2700,1200,230,524,2700,1200,230,525,2700,1200,230,526,2700,1200,230,527,2700,1200,230,528,2700,1200,230,529,2700,1200,230,530,2700,1200,230,531,2700,1200,230,532,2700,1200,230,533,2700,1200,230,534,2700,1200,230,535,2700,1200,230,536,2700,1200,230,537,2700,1200,230,538,2700,1200,230,539,2700,1200,230,540,2700,1200,230,541,2700,1200,230,542,2700,1200,230,543,2700,1200,230,544,2700,1200,230,545,2700,1200,230,546,2700,1200,230,547,2700,1200,230,548,2700,1200,230,549,2700,1200,230,550,2700,1200,230,551,2700,1200,230,552,2700,1200,230,553,2700,1200,230,554,2700,1200,230,555,2700,1200,230,556,2700,1200,230,557,2700,1200,230,558,2700,1200,230,559,2700,1200,230,560,2700,1200,230,561,2700,1200,230,562,2700,1200,230,563,2700,1200,230,564,2700,1200,230,565,2700,1200,230,566,2700,1200,230,567,2700,1200,230,568,2700,1200,230,569,2700,1200,230,570,2700,1200,230,571,2700,1200,230,572,2700,1200,230,573,2700,1200,230,574,2700,1200,230,575,2700,1200,230,576,2700,1200,230,577,2700,1200,230,578,2700,1200,230,579,2700,1200,230,580,2700,1200,230,581,2700,1200,230,582,2700,1200,230,583,2700,1200,230,584,2700,1200,230,585,2700,1200,230,586,2700,1200,230,587,2700,1200,230,588,2700,1200,230,589,2700,1200,230,590,2700,1200,230,591,2700,1200,230,592,2700,1200,230,593,2700,1200,230,594,2700,1200,230,595,2700,1200,230,596,2700,1200,230,597,2700,1200,230,598,2700,1200,230,599,2700,1200,230,600,2700,1200,230,601,2700,1200,230,602,2700,1200,230,603,2700,1200,230,604,2700,1200,230,605,2700,1200,230,606,2700,1200,230,607,2700,1200,230,608,2700,1200,230,609,2700,1200,230,610,2700,1200,230,611,2700,1200,230,612,2700,1200,230,613,2700,1200,230,614,2700,1200,230,615,2700,1200,230,616,2700,1200,230,617,2700,1200,230,618,2700,1200,230,619,2700,1200,230,620,2700,1200,230,621,2700,1200,230,622,2700,1200,230,623,2700,1200,230,624,2700,1200,230,625,2700,1200,230,626,2700,1200,230,627,2700,1200,230,628,2700,1200,230,629,2700,1200,230,630,2700,1200,230,631,2700,1200,230,632,2700,1200,230,633,2700,1200,230,634,2700,1200,230,635,2700,1200,230,636,2700,1200,230,637,2700,1200,230,638,2700,1200,230,639,2700,1200,230,640,2700,1200,230,641,2700,1200,230,642,2700,1200,230,643,2700,1200,230,644,2700,1200,230,645,2700,1200,230,646,2700,1200,230,647,2700,1200,230,648,2700,1200,230,649,2700,1200,230,650,2700,1200,230,651,2700,1200,230,652,2700,1200,230,653,2700,1200,230,654,2700,1200,230,655,2700,1200,230,656,2700,1200,230,657,2700,1200,230,658,2700,1200,230,659,2700,1200,230,660,2700,1200,230,661,2700,1200,230,662,2700,1200,230,663,2700,1200,230,664,2700,1200,230,665,2700,1200,230,666,2700,1200,230,667,2700,1200,230,668,2700,1200,230,669,2700,1200,230,670,2700,1200,230,671,2700,1200,230,672,2700,1200,230,673,2700,1200,230,674,2700,1200,230,675,2700,1200,230,676,2700,1200,230,677,2700,1200,230,678,2700,1200,230,679,2700,1200,230,680,2700,1200,230,681,2700,1200,230,682,2700,1200,230,683,2700,1200,230,684,2700,1200,230,685,2700,1200,230,686,2700,1200,230,687,2700,
	1200,230,688,2700,1200,230,689,2700,1200,230,690,2700,1200,230,691,2700,1200,230,692,2700,1200,230,693,2700,1200,230,694,2700,1200,230,695,2700,1200,230,696,2700,1200,230,697,2700,1200,230,698,2700,1200,230,699,2700,1200,230,700,2700,1200,230,701,2700,1200,230,702,2700,1200,230,703,2700,1200,230,704,2700,1200,230,705,2700,1200,230,706,2700,1200,230,707,2700,1200,230,708,2700,1200,230,709,2700,1200,230,710,2700,1200,230,711,2700,1200,230,712,2700,1200,230,713,2700,1200,230,714,2700,1200,230,715,2700,1200,230,716,2700,1200,230,717,2700,1200,230,718,2700,1200,230,719,2700,1200,230,720,2700,1200,230,721,2700,1200,230,722,2700,1200,230,723,2700,1200,230,724,2700,1200,230,725,2700,1200,230,726,2700,1200,230,727,2700,1200,230,728,2700,1200,230,729,2700,1200,230,730,2700,1200,230,731,2700,1200,230,732,2700,1200,230,733,2700,1200,230,734,2700,1200,230,735,2700,1200,230,736,2700,1200,230,737,2700,1200,230,738,2700,1200,230,739,2700,1200,230,740,2700,1200,230,741,2700,1200,230,742,2700,1200,230,743,2700,1200,230,744,2700,1200,230,745,2700,1200,230,746,2700,1200,230,747,2700,1200,230,748,2700,1200,230,749,2700,1200,230,750,2700,1200,230,751,2700,1200,230,752,2700,1200,230,753,2700,1200,230,754,2700,1200,230,755,2700,1200,230,756,2700,1200,230,757,2700,1200,230,758,2700,1200,230,759,2700,1200,230,760,2700,1200,230,761,2700,1200,230,762,2700,1200,230,763,2700,1200,230,764,2700,1200,230,765,2700,1200,230,766,2700,1200,230,767,2700,1200,230,768,2700,1200,230,769,2700,1200,230,770,2700,1200,230,771,2700,1200,230,772,2700,1200,230,773,2700,1200,230,774,2700,1200,230,775,2700,1200,230,776,2700,1200,230,777,2700,1200,230,778,2700,1200,230,779,2700,1200,230,780,2700,1200,230,781,2700,1200,230,782,2700,1200,230,783,2700,1200,230,784,2700,1200,230,785,2700,1200,230,786,2700,1200,230,787,2700,1200,230,788,2700,1200,230,789,2700,1200,230,790,2700,1200,230,791,2700,1200,230,792,2700,1200,230,793,2700,1200,230,794,2700,1200,230,795,2700,1200,230,796,2700,1200,230,797,2700,1200,230,798,2700,1200,230,799,2700,1200,230,800,2700,1200,230,801,2700,1200,230,802,2700,1200,230,803,2700,1200,230,804,2700,1200,230,805,2700,1200,230,806,2700,1200,230,807,2700,1200,230,808,2700,1200,230,809,2700,1200,230,810,2700,1200,230,811,2700,1200,230,812,2700,1200,230,813,2700,1200,230,814,2700,1200,230,815,2700,1200,230,816,2700,1200,230,817,2700,1200,230,818,2700,1200,230,819,2700,1200,230,820,2700,1200,230,821,2700,1200,230,822,2700,1200,230,823,2700,1200,230,824,2700,1200,230,825,2700,1200,230,826,2700,1200,230,827,2700,1200,230,828,2700,1200,230,829,2700,1200,230,830,2700,1200,230,831,2700,1200,230,832,2700,1200,230,833,2700,1200,230,834,2700,1200,230,835,2700,1200,230,836,2700,1200,230,837,2700,1200,230,838,2700,1200,230,839,2700,1200,230,840,2700,1200,230,841,2700,1200,230,842,2700,1200,230,843,2700,1200,230,844,2700,1200,230,845,2700,1200,230,846,2700,1200,230,847,2700,1200,230,848,2700,1200,230,849,2700,1200,230,850,2700,1200,230,851,2700,1200,230,852,2700,1200,230,853,2700,1200,230,854,2700,1200,230,855,2700,1200,230,856,2700,1200,230,857,2700,1200,230,858,2700,1200,230,859,2700,1200,230,860,2700,1200,230,861,2700,1200,230,862,2700,1200,230,863,2700,1200,230,864,2700,1200,230,865,2700,1200,230,866,2700,1200,230,867,2700,1200,230,868,2700,1200,230,869,2700,1200,230,870,2700,1200,230,871,2700,1200,230,872,2700,1200,230,873,2700,1200,230,874,2700,1200,230,875,2700,1200,230,876,2700,1200,230,877,2700,1200,230,878,2700,1200,230,879,2700,1200,230,880,2700,1200,230,881,2700,1200,230,882,2700,1200,230,883,2700,1200,230,884,2700,1200,230,885,2700,1200,230,886,2700,1200,230,887,2700,1200,230,888,2700,1200,230,889,2700,1200,230,890,2700,1200,230,891,2700,1200,230,892,2700,1200,230,893,2700,1200,230,894,2700,1200,230,895,2700,1200,230,896,2700,1200,230,897,2700,1200,230,898,2700,1200,230,899,2700,1200,230,900,2700,1200,230,901,2700,1200,230,902,2700,1200,230,903,2700,1200,230,904,2700,1200,230,905,2700,1200,230,906,2700,1200,230,907,2700,1200,230,908,2700,1200,230,909,2700,1200,230,910,2700,1200,230,911,2700,1200,230,912,2700,1200,230,913,2700,1200,230,914,2700,1200
	,230,915,2700,1200,230,916,2700,1200,230,917,2700,1200,230,918,2700,1200,230,919,2700,1200,230,920,2700,1200,230,921,2700,1200,230,922,2700,1200,230,923,2700,1200,230,924,2700,1200,230,925,2700,1200,230,926,2700,1200,230,927,2700,1200,230,928,2700,1200,230,929,2700,1200,230,930,2700,1200,230,931,2700,1200,230,932,2700,1200,230,933,2700,1200,230,934,2700,1200,230,935,2700,1200,230,936,2700,1200,230,937,2700,1200,230,938,2700,1200,230,939,2700,1200,230,940,2700,1200,230,941,2700,1200,230,942,2700,1200,230,943,2700,1200,230,944,2700,1200,230,945,2700,1200,230,946,2700,1200,230,947,2700,1200,230,948,2700,1200,230,949,2700,1200,230,950,2700,1200,230,951,2700,1200,230,952,2700,1200,230,953,2700,1200,230,954,2700,1200,230,955,2700,1200,230,956,2700,1200,230,957,2700,1200,230,958,2700,1200,230,959,2700,1200,230,960,2700,1200,230,961,2700,1200,230,962,2700,1200,230,963,2700,1200,230,964,2700,1200,230,965,2700,1200,230,966,2700,1200,230,967,2700,1200,230,968,2700,1200,230,969,2700,1200,230,970,2700,1200,230,971,2700,1200,230,972,2700,1200,230,973,2700,1200,230,974,2700,1200,230,975,2700,1200,230,976,2700,1200,230,977,2700,1200,230,978,2700,1200,230,979,2700,1200,230,980,2700,1200,230,981,2700,1200,230,982,2700,1200,230,983,2700,1200,230,984,2700,1200,230,985,2700,1200,230,986,2700,1200,230,987,2700,1200,230,988,2700,1200,230,989,2700,1200,230,990,2700,1200,230,991,2700,1200,230,992,2700,1200,230,993,2700,1200,230,994,2700,1200,230,995,2700,1200,230,996,2700,1200,230,997,2700,1200,230,998,2700,1200,230,999,2700,1200,230,1000,2700,1200,230,1001,2700,1200,230,1002,2700,1200,230,1003,2700,1200,230,1004,2700,1200,230,1005,2700,1200,230,1006,2700,1200,230,1007,2700,1200,230,1008,2700,1200,230,1009,2700,1200,230,1010,2700,1200,230,1011,2700,1200,230,1012,2700,1200,230,1013,2700,1200,230,1014,2700,1200,230,1015,2700,1200,230,1016,2700,1200,230,1017,2700,1200,230,1018,2700,1200,230,1019,2700,1200,230,1020,2700,1200,230,1021,2700,1200,230,1022,2700,1200,230,1023,2700,1200,230,1024,2700,1200,230,1025,2700,1200,230,1026,2700,1200,230,1027,2700,1200,230,1028,2700,1200,230,1029,2700,1200,230,1030,2700,1200,230,1031,2700,1200,230,1032,2700,1200,230,1033,2700,1200,230,1034,2700,1200,230,1035,2700,1200,230,1036,2700,1200,230,1037,2700,1200,230,1038,2700,1200,230,1039,2700,1200,230,1040,2700,1200,230,1041,2700,1200,230,1042,2700,1200,230,1043,2700,1200,230,1044,2700,1200,230,1045,2700,1200,230,1046,2700,1200,230,1047,2700,1200,230,1048,2700,1200,230,1049,2700,1200,230,1050,2700,1200,230,1051,2700,1200,230,1052,2700,1200,230,1053,2700,1200,230,1054,2700,1200,230,1055,2700,1200,230,1056,2700,1200,230,1057,2700,1200,230,1058,2700,1200,230,1059,2700,1200,230,1060,2700,1200,230,1061,2700,1200,230,1062,2700,1200,230,1063,2700,1200,230,1064,2700,1200,230,1065,2700,1200,230,1066,2700,1200,230,1067,2700,1200,230,1068,2700,1200,230,1069,2700,1200,230,1070,2700,1200,230,1071,2700,1200,230,1072,2700,1200,230,1073,2700,1200,230,1074,2700,1200,230,1075,2700,1200,230,1076,2700,1200,230,1077,2700,1200,230,1078,2700,1200,230,1079,2700,1200,230,
};

//TopTouch Spec B
static u16 GuitarTestPlatformINI_TOPTOUCH[TOTAL_PIXEL_NUM*4]=
{
	0,2700,1200,230,1,2700,1200,230,2,2700,1200,230,3,2700,1200,230,4,2700,1200,230,5,2700,1200,230,6,2700,1200,230,7,2700,1200,230,8,2700,1200,230,9,2700,1200,230,10,2700,1200,230,11,2700,1200,230,12,2700,1200,230,13,2700,1200,230,14,2700,1200,230,15,2700,1200,230,16,2700,1200,230,17,2700,1200,230,18,2700,1200,230,19,2700,1200,230,20,2700,1200,230,21,2700,1200,230,22,2700,1200,230,23,2700,1200,230,24,2700,1200,230,25,2700,1200,230,26,2700,1200,230,27,2700,1200,230,28,2700,1200,230,29,2700,1200,230,30,2700,1200,230,31,2700,1200,230,32,2700,1200,230,33,2700,1200,230,34,2700,1200,230,35,2700,1200,230,36,2700,1200,230,37,2700,1200,230,38,2700,1200,230,39,2700,1200,230,40,2700,1200,230,41,2700,1200,230,42,2700,1200,230,43,2700,1200,230,44,2700,1200,230,45,2700,1200,230,46,2700,1200,230,47,2700,1200,230,48,2700,1200,230,49,2700,1200,230,50,2700,1200,230,51,2700,1200,230,52,2700,1200,230,53,2700,1200,230,54,2700,1200,230,55,2700,1200,230,56,2700,1200,230,57,2700,1200,230,58,2700,1200,230,59,2700,1200,230,60,2700,1200,230,61,2700,1200,230,62,2700,1200,230,63,2700,1200,230,64,2700,1200,230,65,2700,1200,230,66,2700,1200,230,67,2700,1200,230,68,2700,1200,230,69,2700,1200,230,70,2700,1200,230,71,2700,1200,230,72,2700,1200,230,73,2700,1200,230,74,2700,1200,230,75,2700,1200,230,76,2700,1200,230,77,2700,1200,230,78,2700,1200,230,79,2700,1200,230,80,2700,1200,230,81,2700,1200,230,82,2700,1200,230,83,2700,1200,230,84,2700,1200,230,85,2700,1200,230,86,2700,1200,230,87,2700,1200,230,88,2700,1200,230,89,2700,1200,230,90,2700,1200,230,91,2700,1200,230,92,2700,1200,230,93,2700,1200,230,94,2700,1200,230,95,2700,1200,230,96,2700,1200,230,97,2700,1200,230,98,2700,1200,230,99,2700,1200,230,100,2700,1200,230,101,2700,1200,230,102,2700,1200,230,103,2700,1200,230,104,2700,1200,230,105,2700,1200,230,106,2700,1200,230,107,2700,1200,230,108,2700,1200,230,109,2700,1200,230,110,2700,1200,230,111,2700,1200,230,112,2700,1200,230,113,2700,1200,230,114,2700,1200,230,115,2700,1200,230,116,2700,1200,230,117,2700,1200,230,118,2700,1200,230,119,2700,1200,230,120,2700,1200,230,121,2700,1200,230,122,2700,1200,230,123,2700,1200,230,124,2700,1200,230,125,2700,1200,230,126,2700,1200,230,127,2700,1200,230,128,2700,1200,230,129,2700,1200,230,130,2700,1200,230,131,2700,1200,230,132,2700,1200,230,133,2700,1200,230,134,2700,1200,230,135,2700,1200,230,136,2700,1200,230,137,2700,1200,230,138,2700,1200,230,139,2700,1200,230,140,2700,1200,230,141,2700,1200,230,142,2700,1200,230,143,2700,1200,230,144,2700,1200,230,145,2700,1200,230,146,2700,1200,230,147,2700,1200,230,148,2700,1200,230,149,2700,1200,230,150,2700,1200,230,151,2700,1200,230,152,2700,1200,230,153,2700,1200,230,154,2700,1200,230,155,2700,1200,230,156,2700,1200,230,157,2700,1200,230,158,2700,1200,230,159,2700,1200,230,160,2700,1200,230,161,2700,1200,230,162,2700,1200,230,163,2700,1200,230,164,2700,1200,230,165,2700,1200,230,166,2700,1200,230,167,2700,1200,230,168,2700,1200,230,169,2700,1200,230,170,2700,1200,230,171,2700,1200,230,172,2700,1200,230,173,2700,1200,230,174,2700,1200,230,175,2700,1200,230,176,2700,1200,230,177,2700,1200,230,178,2700,1200,230,179,2700,1200,230,180,2700,1200,230,181,2700,1200,230,182,2700,1200,230,183,2700,1200,230,184,2700,1200,230,185,2700,1200,230,186,2700,1200,230,187,2700,1200,230,188,2700,1200,230,189,2700,1200,230,190,2700,1200,230,191,2700,1200,230,192,2700,1200,230,193,2700,1200,230,194,2700,1200,230,195,2700,1200,230,196,2700,1200,230,197,2700,1200,230,198,2700,1200,230,199,2700,1200,230,200,2700,1200,230,201,2700,1200,230,202,2700,1200,230,203,2700,1200,230,204,2700,1200,230,205,2700,1200,230,206,2700,1200,230,207,2700,1200,230,208,2700,1200,230,209,2700,1200,230,210,2700,1200,230,211,2700,1200,230,212,2700,1200,230,213,2700,1200,230,214,2700,1200,230,215,2700,1200,230,216,2700,1200,230,217,2700,1200,230,218,2700,1200,230,219,2700,1200,230,220,2700,1200,230,221,2700,1200,230,222,2700,1200,230,223,2700,1200,230,224,2700,1200,230,225,2700,1200,230,226,2700,1200,230,227,2700,1200,230,228,2700,1200,230,229,2700,1200,230,230,2700,1200,230,231,2700,1200,230,232,2700,1200,230,233,
	2700,1200,230,234,2700,1200,230,235,2700,1200,230,236,2700,1200,230,237,2700,1200,230,238,2700,1200,230,239,2700,1200,230,240,2700,1200,230,241,2700,1200,230,242,2700,1200,230,243,2700,1200,230,244,2700,1200,230,245,2700,1200,230,246,2700,1200,230,247,2700,1200,230,248,2700,1200,230,249,2700,1200,230,250,2700,1200,230,251,2700,1200,230,252,2700,1200,230,253,2700,1200,230,254,2700,1200,230,255,2700,1200,230,256,2700,1200,230,257,2700,1200,230,258,2700,1200,230,259,2700,1200,230,260,2700,1200,230,261,2700,1200,230,262,2700,1200,230,263,2700,1200,230,264,2700,1200,230,265,2700,1200,230,266,2700,1200,230,267,2700,1200,230,268,2700,1200,230,269,2700,1200,230,270,2700,1200,230,271,2700,1200,230,272,2700,1200,230,273,2700,1200,230,274,2700,1200,230,275,2700,1200,230,276,2700,1200,230,277,2700,1200,230,278,2700,1200,230,279,2700,1200,230,280,2700,1200,230,281,2700,1200,230,282,2700,1200,230,283,2700,1200,230,284,2700,1200,230,285,2700,1200,230,286,2700,1200,230,287,2700,1200,230,288,2700,1200,230,289,2700,1200,230,290,2700,1200,230,291,2700,1200,230,292,2700,1200,230,293,2700,1200,230,294,2700,1200,230,295,2700,1200,230,296,2700,1200,230,297,2700,1200,230,298,2700,1200,230,299,2700,1200,230,300,2700,1200,230,301,2700,1200,230,302,2700,1200,230,303,2700,1200,230,304,2700,1200,230,305,2700,1200,230,306,2700,1200,230,307,2700,1200,230,308,2700,1200,230,309,2700,1200,230,310,2700,1200,230,311,2700,1200,230,312,2700,1200,230,313,2700,1200,230,314,2700,1200,230,315,2700,1200,230,316,2700,1200,230,317,2700,1200,230,318,2700,1200,230,319,2700,1200,230,320,2700,1200,230,321,2700,1200,230,322,2700,1200,230,323,2700,1200,230,324,2700,1200,230,325,2700,1200,230,326,2700,1200,230,327,2700,1200,230,328,2700,1200,230,329,2700,1200,230,330,2700,1200,230,331,2700,1200,230,332,2700,1200,230,333,2700,1200,230,334,2700,1200,230,335,2700,1200,230,336,2700,1200,230,337,2700,1200,230,338,2700,1200,230,339,2700,1200,230,340,2700,1200,230,341,2700,1200,230,342,2700,1200,230,343,2700,1200,230,344,2700,1200,230,345,2700,1200,230,346,2700,1200,230,347,2700,1200,230,348,2700,1200,230,349,2700,1200,230,350,2700,1200,230,351,2700,1200,230,352,2700,1200,230,353,2700,1200,230,354,2700,1200,230,355,2700,1200,230,356,2700,1200,230,357,2700,1200,230,358,2700,1200,230,359,2700,1200,230,360,2700,1200,230,361,2700,1200,230,362,2700,1200,230,363,2700,1200,230,364,2700,1200,230,365,2700,1200,230,366,2700,1200,230,367,2700,1200,230,368,2700,1200,230,369,2700,1200,230,370,2700,1200,230,371,2700,1200,230,372,2700,1200,230,373,2700,1200,230,374,2700,1200,230,375,2700,1200,230,376,2700,1200,230,377,2700,1200,230,378,2700,1200,230,379,2700,1200,230,380,2700,1200,230,381,2700,1200,230,382,2700,1200,230,383,2700,1200,230,384,2700,1200,230,385,2700,1200,230,386,2700,1200,230,387,2700,1200,230,388,2700,1200,230,389,2700,1200,230,390,2700,1200,230,391,2700,1200,230,392,2700,1200,230,393,2700,1200,230,394,2700,1200,230,395,2700,1200,230,396,2700,1200,230,397,2700,1200,230,398,2700,1200,230,399,2700,1200,230,400,2700,1200,230,401,2700,1200,230,402,2700,1200,230,403,2700,1200,230,404,2700,1200,230,405,2700,1200,230,406,2700,1200,230,407,2700,1200,230,408,2700,1200,230,409,2700,1200,230,410,2700,1200,230,411,2700,1200,230,412,2700,1200,230,413,2700,1200,230,414,2700,1200,230,415,2700,1200,230,416,2700,1200,230,417,2700,1200,230,418,2700,1200,230,419,2700,1200,230,420,2700,1200,230,421,2700,1200,230,422,2700,1200,230,423,2700,1200,230,424,2700,1200,230,425,2700,1200,230,426,2700,1200,230,427,2700,1200,230,428,2700,1200,230,429,2700,1200,230,430,2700,1200,230,431,2700,1200,230,432,2700,1200,230,433,2700,1200,230,434,2700,1200,230,435,2700,1200,230,436,2700,1200,230,437,2700,1200,230,438,2700,1200,230,439,2700,1200,230,440,2700,1200,230,441,2700,1200,230,442,2700,1200,230,443,2700,1200,230,444,2700,1200,230,445,2700,1200,230,446,2700,1200,230,447,2700,1200,230,448,2700,1200,230,449,2700,1200,230,450,2700,1200,230,451,2700,1200,230,452,2700,1200,230,453,2700,1200,230,454,2700,1200,230,455,2700,1200,230,456,2700,1200,230,457,2700,1200,230,458,2700,1200,230,459,2700,1200,230,460,2700
	,1200,230,461,2700,1200,230,462,2700,1200,230,463,2700,1200,230,464,2700,1200,230,465,2700,1200,230,466,2700,1200,230,467,2700,1200,230,468,2700,1200,230,469,2700,1200,230,470,2700,1200,230,471,2700,1200,230,472,2700,1200,230,473,2700,1200,230,474,2700,1200,230,475,2700,1200,230,476,2700,1200,230,477,2700,1200,230,478,2700,1200,230,479,2700,1200,230,480,2700,1200,230,481,2700,1200,230,482,2700,1200,230,483,2700,1200,230,484,2700,1200,230,485,2700,1200,230,486,2700,1200,230,487,2700,1200,230,488,2700,1200,230,489,2700,1200,230,490,2700,1200,230,491,2700,1200,230,492,2700,1200,230,493,2700,1200,230,494,2700,1200,230,495,2700,1200,230,496,2700,1200,230,497,2700,1200,230,498,2700,1200,230,499,2700,1200,230,500,2700,1200,230,501,2700,1200,230,502,2700,1200,230,503,2700,1200,230,504,2700,1200,230,505,2700,1200,230,506,2700,1200,230,507,2700,1200,230,508,2700,1200,230,509,2700,1200,230,510,2700,1200,230,511,2700,1200,230,512,2700,1200,230,513,2700,1200,230,514,2700,1200,230,515,2700,1200,230,516,2700,1200,230,517,2700,1200,230,518,2700,1200,230,519,2700,1200,230,520,2700,1200,230,521,2700,1200,230,522,2700,1200,230,523,2700,1200,230,524,2700,1200,230,525,2700,1200,230,526,2700,1200,230,527,2700,1200,230,528,2700,1200,230,529,2700,1200,230,530,2700,1200,230,531,2700,1200,230,532,2700,1200,230,533,2700,1200,230,534,2700,1200,230,535,2700,1200,230,536,2700,1200,230,537,2700,1200,230,538,2700,1200,230,539,2700,1200,230,540,2700,1200,230,541,2700,1200,230,542,2700,1200,230,543,2700,1200,230,544,2700,1200,230,545,2700,1200,230,546,2700,1200,230,547,2700,1200,230,548,2700,1200,230,549,2700,1200,230,550,2700,1200,230,551,2700,1200,230,552,2700,1200,230,553,2700,1200,230,554,2700,1200,230,555,2700,1200,230,556,2700,1200,230,557,2700,1200,230,558,2700,1200,230,559,2700,1200,230,560,2700,1200,230,561,2700,1200,230,562,2700,1200,230,563,2700,1200,230,564,2700,1200,230,565,2700,1200,230,566,2700,1200,230,567,2700,1200,230,568,2700,1200,230,569,2700,1200,230,570,2700,1200,230,571,2700,1200,230,572,2700,1200,230,573,2700,1200,230,574,2700,1200,230,575,2700,1200,230,576,2700,1200,230,577,2700,1200,230,578,2700,1200,230,579,2700,1200,230,580,2700,1200,230,581,2700,1200,230,582,2700,1200,230,583,2700,1200,230,584,2700,1200,230,585,2700,1200,230,586,2700,1200,230,587,2700,1200,230,588,2700,1200,230,589,2700,1200,230,590,2700,1200,230,591,2700,1200,230,592,2700,1200,230,593,2700,1200,230,594,2700,1200,230,595,2700,1200,230,596,2700,1200,230,597,2700,1200,230,598,2700,1200,230,599,2700,1200,230,600,2700,1200,230,601,2700,1200,230,602,2700,1200,230,603,2700,1200,230,604,2700,1200,230,605,2700,1200,230,606,2700,1200,230,607,2700,1200,230,608,2700,1200,230,609,2700,1200,230,610,2700,1200,230,611,2700,1200,230,612,2700,1200,230,613,2700,1200,230,614,2700,1200,230,615,2700,1200,230,616,2700,1200,230,617,2700,1200,230,618,2700,1200,230,619,2700,1200,230,620,2700,1200,230,621,2700,1200,230,622,2700,1200,230,623,2700,1200,230,624,2700,1200,230,625,2700,1200,230,626,2700,1200,230,627,2700,1200,230,628,2700,1200,230,629,2700,1200,230,630,2700,1200,230,631,2700,1200,230,632,2700,1200,230,633,2700,1200,230,634,2700,1200,230,635,2700,1200,230,636,2700,1200,230,637,2700,1200,230,638,2700,1200,230,639,2700,1200,230,640,2700,1200,230,641,2700,1200,230,642,2700,1200,230,643,2700,1200,230,644,2700,1200,230,645,2700,1200,230,646,2700,1200,230,647,2700,1200,230,648,2700,1200,230,649,2700,1200,230,650,2700,1200,230,651,2700,1200,230,652,2700,1200,230,653,2700,1200,230,654,2700,1200,230,655,2700,1200,230,656,2700,1200,230,657,2700,1200,230,658,2700,1200,230,659,2700,1200,230,660,2700,1200,230,661,2700,1200,230,662,2700,1200,230,663,2700,1200,230,664,2700,1200,230,665,2700,1200,230,666,2700,1200,230,667,2700,1200,230,668,2700,1200,230,669,2700,1200,230,670,2700,1200,230,671,2700,1200,230,672,2700,1200,230,673,2700,1200,230,674,2700,1200,230,675,2700,1200,230,676,2700,1200,230,677,2700,1200,230,678,2700,1200,230,679,2700,1200,230,680,2700,1200,230,681,2700,1200,230,682,2700,1200,230,683,2700,1200,230,684,2700,1200,230,685,2700,1200,230,686,2700,1200,230,687,2700,
	1200,230,688,2700,1200,230,689,2700,1200,230,690,2700,1200,230,691,2700,1200,230,692,2700,1200,230,693,2700,1200,230,694,2700,1200,230,695,2700,1200,230,696,2700,1200,230,697,2700,1200,230,698,2700,1200,230,699,2700,1200,230,700,2700,1200,230,701,2700,1200,230,702,2700,1200,230,703,2700,1200,230,704,2700,1200,230,705,2700,1200,230,706,2700,1200,230,707,2700,1200,230,708,2700,1200,230,709,2700,1200,230,710,2700,1200,230,711,2700,1200,230,712,2700,1200,230,713,2700,1200,230,714,2700,1200,230,715,2700,1200,230,716,2700,1200,230,717,2700,1200,230,718,2700,1200,230,719,2700,1200,230,720,2700,1200,230,721,2700,1200,230,722,2700,1200,230,723,2700,1200,230,724,2700,1200,230,725,2700,1200,230,726,2700,1200,230,727,2700,1200,230,728,2700,1200,230,729,2700,1200,230,730,2700,1200,230,731,2700,1200,230,732,2700,1200,230,733,2700,1200,230,734,2700,1200,230,735,2700,1200,230,736,2700,1200,230,737,2700,1200,230,738,2700,1200,230,739,2700,1200,230,740,2700,1200,230,741,2700,1200,230,742,2700,1200,230,743,2700,1200,230,744,2700,1200,230,745,2700,1200,230,746,2700,1200,230,747,2700,1200,230,748,2700,1200,230,749,2700,1200,230,750,2700,1200,230,751,2700,1200,230,752,2700,1200,230,753,2700,1200,230,754,2700,1200,230,755,2700,1200,230,756,2700,1200,230,757,2700,1200,230,758,2700,1200,230,759,2700,1200,230,760,2700,1200,230,761,2700,1200,230,762,2700,1200,230,763,2700,1200,230,764,2700,1200,230,765,2700,1200,230,766,2700,1200,230,767,2700,1200,230,768,2700,1200,230,769,2700,1200,230,770,2700,1200,230,771,2700,1200,230,772,2700,1200,230,773,2700,1200,230,774,2700,1200,230,775,2700,1200,230,776,2700,1200,230,777,2700,1200,230,778,2700,1200,230,779,2700,1200,230,780,2700,1200,230,781,2700,1200,230,782,2700,1200,230,783,2700,1200,230,784,2700,1200,230,785,2700,1200,230,786,2700,1200,230,787,2700,1200,230,788,2700,1200,230,789,2700,1200,230,790,2700,1200,230,791,2700,1200,230,792,2700,1200,230,793,2700,1200,230,794,2700,1200,230,795,2700,1200,230,796,2700,1200,230,797,2700,1200,230,798,2700,1200,230,799,2700,1200,230,800,2700,1200,230,801,2700,1200,230,802,2700,1200,230,803,2700,1200,230,804,2700,1200,230,805,2700,1200,230,806,2700,1200,230,807,2700,1200,230,808,2700,1200,230,809,2700,1200,230,810,2700,1200,230,811,2700,1200,230,812,2700,1200,230,813,2700,1200,230,814,2700,1200,230,815,2700,1200,230,816,2700,1200,230,817,2700,1200,230,818,2700,1200,230,819,2700,1200,230,820,2700,1200,230,821,2700,1200,230,822,2700,1200,230,823,2700,1200,230,824,2700,1200,230,825,2700,1200,230,826,2700,1200,230,827,2700,1200,230,828,2700,1200,230,829,2700,1200,230,830,2700,1200,230,831,2700,1200,230,832,2700,1200,230,833,2700,1200,230,834,2700,1200,230,835,2700,1200,230,836,2700,1200,230,837,2700,1200,230,838,2700,1200,230,839,2700,1200,230,840,2700,1200,230,841,2700,1200,230,842,2700,1200,230,843,2700,1200,230,844,2700,1200,230,845,2700,1200,230,846,2700,1200,230,847,2700,1200,230,848,2700,1200,230,849,2700,1200,230,850,2700,1200,230,851,2700,1200,230,852,2700,1200,230,853,2700,1200,230,854,2700,1200,230,855,2700,1200,230,856,2700,1200,230,857,2700,1200,230,858,2700,1200,230,859,2700,1200,230,860,2700,1200,230,861,2700,1200,230,862,2700,1200,230,863,2700,1200,230,864,2700,1200,230,865,2700,1200,230,866,2700,1200,230,867,2700,1200,230,868,2700,1200,230,869,2700,1200,230,870,2700,1200,230,871,2700,1200,230,872,2700,1200,230,873,2700,1200,230,874,2700,1200,230,875,2700,1200,230,876,2700,1200,230,877,2700,1200,230,878,2700,1200,230,879,2700,1200,230,880,2700,1200,230,881,2700,1200,230,882,2700,1200,230,883,2700,1200,230,884,2700,1200,230,885,2700,1200,230,886,2700,1200,230,887,2700,1200,230,888,2700,1200,230,889,2700,1200,230,890,2700,1200,230,891,2700,1200,230,892,2700,1200,230,893,2700,1200,230,894,2700,1200,230,895,2700,1200,230,896,2700,1200,230,897,2700,1200,230,898,2700,1200,230,899,2700,1200,230,900,2700,1200,230,901,2700,1200,230,902,2700,1200,230,903,2700,1200,230,904,2700,1200,230,905,2700,1200,230,906,2700,1200,230,907,2700,1200,230,908,2700,1200,230,909,2700,1200,230,910,2700,1200,230,911,2700,1200,230,912,2700,1200,230,913,2700,1200,230,914,2700,1200
	,230,915,2700,1200,230,916,2700,1200,230,917,2700,1200,230,918,2700,1200,230,919,2700,1200,230,920,2700,1200,230,921,2700,1200,230,922,2700,1200,230,923,2700,1200,230,924,2700,1200,230,925,2700,1200,230,926,2700,1200,230,927,2700,1200,230,928,2700,1200,230,929,2700,1200,230,930,2700,1200,230,931,2700,1200,230,932,2700,1200,230,933,2700,1200,230,934,2700,1200,230,935,2700,1200,230,936,2700,1200,230,937,2700,1200,230,938,2700,1200,230,939,2700,1200,230,940,2700,1200,230,941,2700,1200,230,942,2700,1200,230,943,2700,1200,230,944,2700,1200,230,945,2700,1200,230,946,2700,1200,230,947,2700,1200,230,948,2700,1200,230,949,2700,1200,230,950,2700,1200,230,951,2700,1200,230,952,2700,1200,230,953,2700,1200,230,954,2700,1200,230,955,2700,1200,230,956,2700,1200,230,957,2700,1200,230,958,2700,1200,230,959,2700,1200,230,960,2700,1200,230,961,2700,1200,230,962,2700,1200,230,963,2700,1200,230,964,2700,1200,230,965,2700,1200,230,966,2700,1200,230,967,2700,1200,230,968,2700,1200,230,969,2700,1200,230,970,2700,1200,230,971,2700,1200,230,972,2700,1200,230,973,2700,1200,230,974,2700,1200,230,975,2700,1200,230,976,2700,1200,230,977,2700,1200,230,978,2700,1200,230,979,2700,1200,230,980,2700,1200,230,981,2700,1200,230,982,2700,1200,230,983,2700,1200,230,984,2700,1200,230,985,2700,1200,230,986,2700,1200,230,987,2700,1200,230,988,2700,1200,230,989,2700,1200,230,990,2700,1200,230,991,2700,1200,230,992,2700,1200,230,993,2700,1200,230,994,2700,1200,230,995,2700,1200,230,996,2700,1200,230,997,2700,1200,230,998,2700,1200,230,999,2700,1200,230,1000,2700,1200,230,1001,2700,1200,230,1002,2700,1200,230,1003,2700,1200,230,1004,2700,1200,230,1005,2700,1200,230,1006,2700,1200,230,1007,2700,1200,230,1008,2700,1200,230,1009,2700,1200,230,1010,2700,1200,230,1011,2700,1200,230,1012,2700,1200,230,1013,2700,1200,230,1014,2700,1200,230,1015,2700,1200,230,1016,2700,1200,230,1017,2700,1200,230,1018,2700,1200,230,1019,2700,1200,230,1020,2700,1200,230,1021,2700,1200,230,1022,2700,1200,230,1023,2700,1200,230,1024,2700,1200,230,1025,2700,1200,230,1026,2700,1200,230,1027,2700,1200,230,1028,2700,1200,230,1029,2700,1200,230,1030,2700,1200,230,1031,2700,1200,230,1032,2700,1200,230,1033,2700,1200,230,1034,2700,1200,230,1035,2700,1200,230,1036,2700,1200,230,1037,2700,1200,230,1038,2700,1200,230,1039,2700,1200,230,1040,2700,1200,230,1041,2700,1200,230,1042,2700,1200,230,1043,2700,1200,230,1044,2700,1200,230,1045,2700,1200,230,1046,2700,1200,230,1047,2700,1200,230,1048,2700,1200,230,1049,2700,1200,230,1050,2700,1200,230,1051,2700,1200,230,1052,2700,1200,230,1053,2700,1200,230,1054,2700,1200,230,1055,2700,1200,230,1056,2700,1200,230,1057,2700,1200,230,1058,2700,1200,230,1059,2700,1200,230,1060,2700,1200,230,1061,2700,1200,230,1062,2700,1200,230,1063,2700,1200,230,1064,2700,1200,230,1065,2700,1200,230,1066,2700,1200,230,1067,2700,1200,230,1068,2700,1200,230,1069,2700,1200,230,1070,2700,1200,230,1071,2700,1200,230,1072,2700,1200,230,1073,2700,1200,230,1074,2700,1200,230,1075,2700,1200,230,1076,2700,1200,230,1077,2700,1200,230,1078,2700,1200,230,1079,2700,1200,230,
};
#endif
static u16 GuitarTestPlatformINI[TOTAL_PIXEL_NUM*4]=
{
	0,2700,1320,200,1,2700,1320,200,2,2700,1320,200,3,2700,1320,200,4,2700,1320,200,5,2700,1320,200,6,2700,1320,200,7,2700,1320,200,8,2700,1320,200,9,2700,1320,200,10,2700,1320,200,11,2700,1320,200,12,2700,1320,200,13,2700,1320,200,14,2700,1320,200,15,2700,1320,200,16,2700,1320,200,17,2700,1320,200,18,2700,1320,200,19,2700,1320,200,20,2700,1320,200,21,2700,1320,200,22,2700,1320,200,23,2700,1320,200,24,2700,1320,200,25,2700,1320,200,26,2700,1320,200,27,2700,1320,200,28,2700,1320,200,29,2700,1320,200,30,2700,1320,200,31,2700,1320,200,32,2700,1320,200,33,2700,1320,200,34,2700,1320,200,35,2700,1320,200,36,2700,1320,200,37,2700,1320,200,38,2700,1320,200,39,2700,1320,200,40,2700,1320,200,41,2700,1320,200,42,2700,1320,200,43,2700,1320,200,44,2700,1320,200,45,2700,1320,200,46,2700,1320,200,47,2700,1320,200,48,2700,1320,200,49,2700,1320,200,50,2700,1320,200,51,2700,1320,200,52,2700,1320,200,53,2700,1320,200,54,2700,1320,200,55,2700,1320,200,56,2700,1320,200,57,2700,1320,200,58,2700,1320,200,59,2700,1320,200,60,2700,1320,200,61,2700,1320,200,62,2700,1320,200,63,2700,1320,200,64,2700,1320,200,65,2700,1320,200,66,2700,1320,200,67,2700,1320,200,68,2700,1320,200,69,2700,1320,200,70,2700,1320,200,71,2700,1320,200,72,2700,1320,200,73,2700,1320,200,74,2700,1320,200,75,2700,1320,200,76,2700,1320,200,77,2700,1320,200,78,2700,1320,200,79,2700,1320,200,80,2700,1320,200,81,2700,1320,200,82,2700,1320,200,83,2700,1320,200,84,2700,1320,200,85,2700,1320,200,86,2700,1320,200,87,2700,1320,200,88,2700,1320,200,89,2700,1320,200,90,2700,1320,200,91,2700,1320,200,92,2700,1320,200,93,2700,1320,200,94,2700,1320,200,95,2700,1320,200,96,2700,1320,200,97,2700,1320,200,98,2700,1320,200,99,2700,1320,200,100,2700,1320,200,101,2700,1320,200,102,2700,1320,200,103,2700,1320,200,104,2700,1320,200,105,2700,1320,200,106,2700,1320,200,107,2700,1320,200,108,2700,1320,200,109,2700,1320,200,110,2700,1320,200,111,2700,1320,200,112,2700,1320,200,113,2700,1320,200,114,2700,1320,200,115,2700,1320,200,116,2700,1320,200,117,2700,1320,200,118,2700,1320,200,119,2700,1320,200,120,2700,1320,200,121,2700,1320,200,122,2700,1320,200,123,2700,1320,200,124,2700,1320,200,125,2700,1320,200,126,2700,1320,200,127,2700,1320,200,128,2700,1320,200,129,2700,1320,200,130,2700,1320,200,131,2700,1320,200,132,2700,1320,200,133,2700,1320,200,134,2700,1320,200,135,2700,1320,200,136,2700,1320,200,137,2700,1320,200,138,2700,1320,200,139,2700,1320,200,140,2700,1320,200,141,2700,1320,200,142,2700,1320,200,143,2700,1320,200,144,2700,1320,200,145,2700,1320,200,146,2700,1320,200,147,2700,1320,200,148,2700,1320,200,149,2700,1320,200,150,2700,1320,200,151,2700,1320,200,152,2700,1320,200,153,2700,1320,200,154,2700,1320,200,155,2700,1320,200,156,2700,1320,200,157,2700,1320,200,158,2700,1320,200,159,2700,1320,200,160,2700,1320,200,161,2700,1320,200,162,2700,1320,200,163,2700,1320,200,164,2700,1320,200,165,2700,1320,200,166,2700,1320,200,167,2700,1320,200,168,2700,1320,200,169,2700,1320,200,170,2700,1320,200,171,2700,1320,200,172,2700,1320,200,173,2700,1320,200,174,2700,1320,200,175,2700,1320,200,176,2700,1320,200,177,2700,1320,200,178,2700,1320,200,179,2700,1320,200,180,2700,1320,200,181,2700,1320,200,182,2700,1320,200,183,2700,1320,200,184,2700,1320,200,185,2700,1320,200,186,2700,1320,200,187,2700,1320,200,188,2700,1320,200,189,2700,1320,200,190,2700,1320,200,191,2700,1320,200,192,2700,1320,200,193,2700,1320,200,194,2700,1320,200,195,2700,1320,200,196,2700,1320,200,197,2700,1320,200,198,2700,1320,200,199,2700,1320,200,200,2700,1320,200,201,2700,1320,200,202,2700,1320,200,203,2700,1320,200,204,2700,1320,200,205,2700,1320,200,206,2700,1320,200,207,2700,1320,200,208,2700,1320,200,209,2700,1320,200,210,2700,1320,200,211,2700,1320,200,212,2700,1320,200,213,2700,1320,200,214,2700,1320,200,215,2700,1320,200,216,2700,1320,200,217,2700,1320,200,218,2700,1320,200,219,2700,1320,200,220,2700,1320,200,221,2700,1320,200,222,2700,1320,200,223,2700,1320,200,224,2700,1320,200,225,2700,1320,200,226,2700,1320,200,227,2700,1320,200,228,2700,1320,200,229,2700,1320,200,230,2700,1320,200,231,2700,1320,200,232,2700,1320,200,233,
	2700,1320,200,234,2700,1320,200,235,2700,1320,200,236,2700,1320,200,237,2700,1320,200,238,2700,1320,200,239,2700,1320,200,240,2700,1320,200,241,2700,1320,200,242,2700,1320,200,243,2700,1320,200,244,2700,1320,200,245,2700,1320,200,246,2700,1320,200,247,2700,1320,200,248,2700,1320,200,249,2700,1320,200,250,2700,1320,200,251,2700,1320,200,252,2700,1320,200,253,2700,1320,200,254,2700,1320,200,255,2700,1320,200,256,2700,1320,200,257,2700,1320,200,258,2700,1320,200,259,2700,1320,200,260,2700,1320,200,261,2700,1320,200,262,2700,1320,200,263,2700,1320,200,264,2700,1320,200,265,2700,1320,200,266,2700,1320,200,267,2700,1320,200,268,2700,1320,200,269,2700,1320,200,270,2700,1320,200,271,2700,1320,200,272,2700,1320,200,273,2700,1320,200,274,2700,1320,200,275,2700,1320,200,276,2700,1320,200,277,2700,1320,200,278,2700,1320,200,279,2700,1320,200,280,2700,1320,200,281,2700,1320,200,282,2700,1320,200,283,2700,1320,200,284,2700,1320,200,285,2700,1320,200,286,2700,1320,200,287,2700,1320,200,288,2700,1320,200,289,2700,1320,200,290,2700,1320,200,291,2700,1320,200,292,2700,1320,200,293,2700,1320,200,294,2700,1320,200,295,2700,1320,200,296,2700,1320,200,297,2700,1320,200,298,2700,1320,200,299,2700,1320,200,300,2700,1320,200,301,2700,1320,200,302,2700,1320,200,303,2700,1320,200,304,2700,1320,200,305,2700,1320,200,306,2700,1320,200,307,2700,1320,200,308,2700,1320,200,309,2700,1320,200,310,2700,1320,200,311,2700,1320,200,312,2700,1320,200,313,2700,1320,200,314,2700,1320,200,315,2700,1320,200,316,2700,1320,200,317,2700,1320,200,318,2700,1320,200,319,2700,1320,200,320,2700,1320,200,321,2700,1320,200,322,2700,1320,200,323,2700,1320,200,324,2700,1320,200,325,2700,1320,200,326,2700,1320,200,327,2700,1320,200,328,2700,1320,200,329,2700,1320,200,330,2700,1320,200,331,2700,1320,200,332,2700,1320,200,333,2700,1320,200,334,2700,1320,200,335,2700,1320,200,336,2700,1320,200,337,2700,1320,200,338,2700,1320,200,339,2700,1320,200,340,2700,1320,200,341,2700,1320,200,342,2700,1320,200,343,2700,1320,200,344,2700,1320,200,345,2700,1320,200,346,2700,1320,200,347,2700,1320,200,348,2700,1320,200,349,2700,1320,200,350,2700,1320,200,351,2700,1320,200,352,2700,1320,200,353,2700,1320,200,354,2700,1320,200,355,2700,1320,200,356,2700,1320,200,357,2700,1320,200,358,2700,1320,200,359,2700,1320,200,360,2700,1320,200,361,2700,1320,200,362,2700,1320,200,363,2700,1320,200,364,2700,1320,200,365,2700,1320,200,366,2700,1320,200,367,2700,1320,200,368,2700,1320,200,369,2700,1320,200,370,2700,1320,200,371,2700,1320,200,372,2700,1320,200,373,2700,1320,200,374,2700,1320,200,375,2700,1320,200,376,2700,1320,200,377,2700,1320,200,378,2700,1320,200,379,2700,1320,200,380,2700,1320,200,381,2700,1320,200,382,2700,1320,200,383,2700,1320,200,384,2700,1320,200,385,2700,1320,200,386,2700,1320,200,387,2700,1320,200,388,2700,1320,200,389,2700,1320,200,390,2700,1320,200,391,2700,1320,200,392,2700,1320,200,393,2700,1320,200,394,2700,1320,200,395,2700,1320,200,396,2700,1320,200,397,2700,1320,200,398,2700,1320,200,399,2700,1320,200,400,2700,1320,200,401,2700,1320,200,402,2700,1320,200,403,2700,1320,200,404,2700,1320,200,405,2700,1320,200,406,2700,1320,200,407,2700,1320,200,408,2700,1320,200,409,2700,1320,200,410,2700,1320,200,411,2700,1320,200,412,2700,1320,200,413,2700,1320,200,414,2700,1320,200,415,2700,1320,200,416,2700,1320,200,417,2700,1320,200,418,2700,1320,200,419,2700,1320,200,420,2700,1320,200,421,2700,1320,200,422,2700,1320,200,423,2700,1320,200,424,2700,1320,200,425,2700,1320,200,426,2700,1320,200,427,2700,1320,200,428,2700,1320,200,429,2700,1320,200,430,2700,1320,200,431,2700,1320,200,432,2700,1320,200,433,2700,1320,200,434,2700,1320,200,435,2700,1320,200,436,2700,1320,200,437,2700,1320,200,438,2700,1320,200,439,2700,1320,200,440,2700,1320,200,441,2700,1320,200,442,2700,1320,200,443,2700,1320,200,444,2700,1320,200,445,2700,1320,200,446,2700,1320,200,447,2700,1320,200,448,2700,1320,200,449,2700,1320,200,450,2700,1320,200,451,2700,1320,200,452,2700,1320,200,453,2700,1320,200,454,2700,1320,200,455,2700,1320,200,456,2700,1320,200,457,2700,1320,200,458,2700,1320,200,459,2700,1320,200,460,2700
	,1320,200,461,2700,1320,200,462,2700,1320,200,463,2700,1320,200,464,2700,1320,200,465,2700,1320,200,466,2700,1320,200,467,2700,1320,200,468,2700,1320,200,469,2700,1320,200,470,2700,1320,200,471,2700,1320,200,472,2700,1320,200,473,2700,1320,200,474,2700,1320,200,475,2700,1320,200,476,2700,1320,200,477,2700,1320,200,478,2700,1320,200,479,2700,1320,200,480,2700,1320,200,481,2700,1320,200,482,2700,1320,200,483,2700,1320,200,484,2700,1320,200,485,2700,1320,200,486,2700,1320,200,487,2700,1320,200,488,2700,1320,200,489,2700,1320,200,490,2700,1320,200,491,2700,1320,200,492,2700,1320,200,493,2700,1320,200,494,2700,1320,200,495,2700,1320,200,496,2700,1320,200,497,2700,1320,200,498,2700,1320,200,499,2700,1320,200,500,2700,1320,200,501,2700,1320,200,502,2700,1320,200,503,2700,1320,200,504,2700,1320,200,505,2700,1320,200,506,2700,1320,200,507,2700,1320,200,508,2700,1320,200,509,2700,1320,200,510,2700,1320,200,511,2700,1320,200,512,2700,1320,200,513,2700,1320,200,514,2700,1320,200,515,2700,1320,200,516,2700,1320,200,517,2700,1320,200,518,2700,1320,200,519,2700,1320,200,520,2700,1320,200,521,2700,1320,200,522,2700,1320,200,523,2700,1320,200,524,2700,1320,200,525,2700,1320,200,526,2700,1320,200,527,2700,1320,200,528,2700,1320,200,529,2700,1320,200,530,2700,1320,200,531,2700,1320,200,532,2700,1320,200,533,2700,1320,200,534,2700,1320,200,535,2700,1320,200,536,2700,1320,200,537,2700,1320,200,538,2700,1320,200,539,2700,1320,200,540,2700,1320,200,541,2700,1320,200,542,2700,1320,200,543,2700,1320,200,544,2700,1320,200,545,2700,1320,200,546,2700,1320,200,547,2700,1320,200,548,2700,1320,200,549,2700,1320,200,550,2700,1320,200,551,2700,1320,200,552,2700,1320,200,553,2700,1320,200,554,2700,1320,200,555,2700,1320,200,556,2700,1320,200,557,2700,1320,200,558,2700,1320,200,559,2700,1320,200,560,2700,1320,200,561,2700,1320,200,562,2700,1320,200,563,2700,1320,200,564,2700,1320,200,565,2700,1320,200,566,2700,1320,200,567,2700,1320,200,568,2700,1320,200,569,2700,1320,200,570,2700,1320,200,571,2700,1320,200,572,2700,1320,200,573,2700,1320,200,574,2700,1320,200,575,2700,1320,200,576,2700,1320,200,577,2700,1320,200,578,2700,1320,200,579,2700,1320,200,580,2700,1320,200,581,2700,1320,200,582,2700,1320,200,583,2700,1320,200,584,2700,1320,200,585,2700,1320,200,586,2700,1320,200,587,2700,1320,200,588,2700,1320,200,589,2700,1320,200,590,2700,1320,200,591,2700,1320,200,592,2700,1320,200,593,2700,1320,200,594,2700,1320,200,595,2700,1320,200,596,2700,1320,200,597,2700,1320,200,598,2700,1320,200,599,2700,1320,200,600,2700,1320,200,601,2700,1320,200,602,2700,1320,200,603,2700,1320,200,604,2700,1320,200,605,2700,1320,200,606,2700,1320,200,607,2700,1320,200,608,2700,1320,200,609,2700,1320,200,610,2700,1320,200,611,2700,1320,200,612,2700,1320,200,613,2700,1320,200,614,2700,1320,200,615,2700,1320,200,616,2700,1320,200,617,2700,1320,200,618,2700,1320,200,619,2700,1320,200,620,2700,1320,200,621,2700,1320,200,622,2700,1320,200,623,2700,1320,200,624,2700,1320,200,625,2700,1320,200,626,2700,1320,200,627,2700,1320,200,628,2700,1320,200,629,2700,1320,200,630,2700,1320,200,631,2700,1320,200,632,2700,1320,200,633,2700,1320,200,634,2700,1320,200,635,2700,1320,200,636,2700,1320,200,637,2700,1320,200,638,2700,1320,200,639,2700,1320,200,640,2700,1320,200,641,2700,1320,200,642,2700,1320,200,643,2700,1320,200,644,2700,1320,200,645,2700,1320,200,646,2700,1320,200,647,2700,1320,200,648,2700,1320,200,649,2700,1320,200,650,2700,1320,200,651,2700,1320,200,652,2700,1320,200,653,2700,1320,200,654,2700,1320,200,655,2700,1320,200,656,2700,1320,200,657,2700,1320,200,658,2700,1320,200,659,2700,1320,200,660,2700,1320,200,661,2700,1320,200,662,2700,1320,200,663,2700,1320,200,664,2700,1320,200,665,2700,1320,200,666,2700,1320,200,667,2700,1320,200,668,2700,1320,200,669,2700,1320,200,670,2700,1320,200,671,2700,1320,200,672,2700,1320,200,673,2700,1320,200,674,2700,1320,200,675,2700,1320,200,676,2700,1320,200,677,2700,1320,200,678,2700,1320,200,679,2700,1320,200,680,2700,1320,200,681,2700,1320,200,682,2700,1320,200,683,2700,1320,200,684,2700,1320,200,685,2700,1320,200,686,2700,1320,200,687,2700,
	1320,200,688,2700,1320,200,689,2700,1320,200,690,2700,1320,200,691,2700,1320,200,692,2700,1320,200,693,2700,1320,200,694,2700,1320,200,695,2700,1320,200,696,2700,1320,200,697,2700,1320,200,698,2700,1320,200,699,2700,1320,200,700,2700,1320,200,701,2700,1320,200,702,2700,1320,200,703,2700,1320,200,704,2700,1320,200,705,2700,1320,200,706,2700,1320,200,707,2700,1320,200,708,2700,1320,200,709,2700,1320,200,710,2700,1320,200,711,2700,1320,200,712,2700,1320,200,713,2700,1320,200,714,2700,1320,200,715,2700,1320,200,716,2700,1320,200,717,2700,1320,200,718,2700,1320,200,719,2700,1320,200,720,2700,1320,200,721,2700,1320,200,722,2700,1320,200,723,2700,1320,200,724,2700,1320,200,725,2700,1320,200,726,2700,1320,200,727,2700,1320,200,728,2700,1320,200,729,2700,1320,200,730,2700,1320,200,731,2700,1320,200,732,2700,1320,200,733,2700,1320,200,734,2700,1320,200,735,2700,1320,200,736,2700,1320,200,737,2700,1320,200,738,2700,1320,200,739,2700,1320,200,740,2700,1320,200,741,2700,1320,200,742,2700,1320,200,743,2700,1320,200,744,2700,1320,200,745,2700,1320,200,746,2700,1320,200,747,2700,1320,200,748,2700,1320,200,749,2700,1320,200,750,2700,1320,200,751,2700,1320,200,752,2700,1320,200,753,2700,1320,200,754,2700,1320,200,755,2700,1320,200,756,2700,1320,200,757,2700,1320,200,758,2700,1320,200,759,2700,1320,200,760,2700,1320,200,761,2700,1320,200,762,2700,1320,200,763,2700,1320,200,764,2700,1320,200,765,2700,1320,200,766,2700,1320,200,767,2700,1320,200,768,2700,1320,200,769,2700,1320,200,770,2700,1320,200,771,2700,1320,200,772,2700,1320,200,773,2700,1320,200,774,2700,1320,200,775,2700,1320,200,776,2700,1320,200,777,2700,1320,200,778,2700,1320,200,779,2700,1320,200,780,2700,1320,200,781,2700,1320,200,782,2700,1320,200,783,2700,1320,200,784,2700,1320,200,785,2700,1320,200,786,2700,1320,200,787,2700,1320,200,788,2700,1320,200,789,2700,1320,200,790,2700,1320,200,791,2700,1320,200,792,2700,1320,200,793,2700,1320,200,794,2700,1320,200,795,2700,1320,200,796,2700,1320,200,797,2700,1320,200,798,2700,1320,200,799,2700,1320,200,800,2700,1320,200,801,2700,1320,200,802,2700,1320,200,803,2700,1320,200,804,2700,1320,200,805,2700,1320,200,806,2700,1320,200,807,2700,1320,200,808,2700,1320,200,809,2700,1320,200,810,2700,1320,200,811,2700,1320,200,812,2700,1320,200,813,2700,1320,200,814,2700,1320,200,815,2700,1320,200,816,2700,1320,200,817,2700,1320,200,818,2700,1320,200,819,2700,1320,200,820,2700,1320,200,821,2700,1320,200,822,2700,1320,200,823,2700,1320,200,824,2700,1320,200,825,2700,1320,200,826,2700,1320,200,827,2700,1320,200,828,2700,1320,200,829,2700,1320,200,830,2700,1320,200,831,2700,1320,200,832,2700,1320,200,833,2700,1320,200,834,2700,1320,200,835,2700,1320,200,836,2700,1320,200,837,2700,1320,200,838,2700,1320,200,839,2700,1320,200,840,2700,1320,200,841,2700,1320,200,842,2700,1320,200,843,2700,1320,200,844,2700,1320,200,845,2700,1320,200,846,2700,1320,200,847,2700,1320,200,848,2700,1320,200,849,2700,1320,200,850,2700,1320,200,851,2700,1320,200,852,2700,1320,200,853,2700,1320,200,854,2700,1320,200,855,2700,1320,200,856,2700,1320,200,857,2700,1320,200,858,2700,1320,200,859,2700,1320,200,860,2700,1320,200,861,2700,1320,200,862,2700,1320,200,863,2700,1320,200,864,2700,1320,200,865,2700,1320,200,866,2700,1320,200,867,2700,1320,200,868,2700,1320,200,869,2700,1320,200,870,2700,1320,200,871,2700,1320,200,872,2700,1320,200,873,2700,1320,200,874,2700,1320,200,875,2700,1320,200,876,2700,1320,200,877,2700,1320,200,878,2700,1320,200,879,2700,1320,200,880,2700,1320,200,881,2700,1320,200,882,2700,1320,200,883,2700,1320,200,884,2700,1320,200,885,2700,1320,200,886,2700,1320,200,887,2700,1320,200,888,2700,1320,200,889,2700,1320,200,890,2700,1320,200,891,2700,1320,200,892,2700,1320,200,893,2700,1320,200,894,2700,1320,200,895,2700,1320,200,896,2700,1320,200,897,2700,1320,200,898,2700,1320,200,899,2700,1320,200,900,2700,1320,200,901,2700,1320,200,902,2700,1320,200,903,2700,1320,200,904,2700,1320,200,905,2700,1320,200,906,2700,1320,200,907,2700,1320,200,908,2700,1320,200,909,2700,1320,200,910,2700,1320,200,911,2700,1320,200,912,2700,1320,200,913,2700,1320,200,914,2700,1320
	,200,915,2700,1320,200,916,2700,1320,200,917,2700,1320,200,918,2700,1320,200,919,2700,1320,200,920,2700,1320,200,921,2700,1320,200,922,2700,1320,200,923,2700,1320,200,924,2700,1320,200,925,2700,1320,200,926,2700,1320,200,927,2700,1320,200,928,2700,1320,200,929,2700,1320,200,930,2700,1320,200,931,2700,1320,200,932,2700,1320,200,933,2700,1320,200,934,2700,1320,200,935,2700,1320,200,936,2700,1320,200,937,2700,1320,200,938,2700,1320,200,939,2700,1320,200,940,2700,1320,200,941,2700,1320,200,942,2700,1320,200,943,2700,1320,200,944,2700,1320,200,945,2700,1320,200,946,2700,1320,200,947,2700,1320,200,948,2700,1320,200,949,2700,1320,200,950,2700,1320,200,951,2700,1320,200,952,2700,1320,200,953,2700,1320,200,954,2700,1320,200,955,2700,1320,200,956,2700,1320,200,957,2700,1320,200,958,2700,1320,200,959,2700,1320,200,960,2700,1320,200,961,2700,1320,200,962,2700,1320,200,963,2700,1320,200,964,2700,1320,200,965,2700,1320,200,966,2700,1320,200,967,2700,1320,200,968,2700,1320,200,969,2700,1320,200,970,2700,1320,200,971,2700,1320,200,972,2700,1320,200,973,2700,1320,200,974,2700,1320,200,975,2700,1320,200,976,2700,1320,200,977,2700,1320,200,978,2700,1320,200,979,2700,1320,200,980,2700,1320,200,981,2700,1320,200,982,2700,1320,200,983,2700,1320,200,984,2700,1320,200,985,2700,1320,200,986,2700,1320,200,987,2700,1320,200,988,2700,1320,200,989,2700,1320,200,990,2700,1320,200,991,2700,1320,200,992,2700,1320,200,993,2700,1320,200,994,2700,1320,200,995,2700,1320,200,996,2700,1320,200,997,2700,1320,200,998,2700,1320,200,999,2700,1320,200,1000,2700,1320,200,1001,2700,1320,200,1002,2700,1320,200,1003,2700,1320,200,1004,2700,1320,200,1005,2700,1320,200,1006,2700,1320,200,1007,2700,1320,200,1008,2700,1320,200,1009,2700,1320,200,1010,2700,1320,200,1011,2700,1320,200,1012,2700,1320,200,1013,2700,1320,200,1014,2700,1320,200,1015,2700,1320,200,1016,2700,1320,200,1017,2700,1320,200,1018,2700,1320,200,1019,2700,1320,200,1020,2700,1320,200,1021,2700,1320,200,1022,2700,1320,200,1023,2700,1320,200,1024,2700,1320,200,1025,2700,1320,200,1026,2700,1320,200,1027,2700,1320,200,1028,2700,1320,200,1029,2700,1320,200,1030,2700,1320,200,1031,2700,1320,200,1032,2700,1320,200,1033,2700,1320,200,1034,2700,1320,200,1035,2700,1320,200,1036,2700,1320,200,1037,2700,1320,200,1038,2700,1320,200,1039,2700,1320,200,1040,2700,1320,200,1041,2700,1320,200,1042,2700,1320,200,1043,2700,1320,200,1044,2700,1320,200,1045,2700,1320,200,1046,2700,1320,200,1047,2700,1320,200,1048,2700,1320,200,1049,2700,1320,200,1050,2700,1320,200,1051,2700,1320,200,1052,2700,1320,200,1053,2700,1320,200,1054,2700,1320,200,1055,2700,1320,200,1056,2700,1320,200,1057,2700,1320,200,1058,2700,1320,200,1059,2700,1320,200,1060,2700,1320,200,1061,2700,1320,200,1062,2700,1320,200,1063,2700,1320,200,1064,2700,1320,200,1065,2700,1320,200,1066,2700,1320,200,1067,2700,1320,200,1068,2700,1320,200,1069,2700,1320,200,1070,2700,1320,200,1071,2700,1320,200,1072,2700,1320,200,1073,2700,1320,200,1074,2700,1320,200,1075,2700,1320,200,1076,2700,1320,200,1077,2700,1320,200,1078,2700,1320,200,1079,2700,1320,200,
};

static bool AbsoluteTotalCheck = true;
static bool AreaAccordCheck = false;
static u16 TotalMaxValue = 2700;
static u16 TotalMinValue = 1320;
#if 0
static u16 TotalMaxValue_GIS = 2700;
static u16 TotalMinValue_GIS = 1200;
static u16 TotalMaxValue_TopTouch = 2700;
static u16 TotalMinValue_TopTouch = 1200;
#endif
static s32 test_result=FAIL;
// add by leo for dynamic change limit value --
extern int gt6108_debug;

s32 gt9xx_short_parse_cfg(void)
{
	u8 i = 0;
	u8 drv_num = 0, sen_num = 0;

	u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};

	if (gtp_i2c_read(i2c_connect_client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
	{
		SET_INFO_LINE_ERR("Failed to read config!");
		return FAIL;
	}

	drv_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT-GT9_REG_CFG_BEG] & 0x1F)
	          + (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+1 -GT9_REG_CFG_BEG] & 0x1F);
	sen_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG] & 0x0F)
	          + ((config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG]>>4) & 0x0F);

	// add by leo for test ++
	drv_num = 40;
	sen_num = 27;

	GTP_INFO("drv_num = %d", drv_num);
	GTP_INFO("sen_num = %d", sen_num);
	// add by leo for test --

	if (drv_num < MIN_DRIVER_NUM || drv_num > MAX_DRIVER_NUM)
	{
		GTP_ERROR("driver number error!");
		return FAIL;
	}
	if (sen_num < MIN_SENSOR_NUM || sen_num > MAX_SENSOR_NUM)
	{
		GTP_ERROR("sensor number error!");
		return FAIL;
	}
	// get sensor and driver order
	memset(cfg_sen_order, 0xFF, MAX_SENSOR_NUM);
	for (i = 0; i < sen_num; ++i)
	{
		cfg_sen_order[i] = config[GTP_ADDR_LENGTH + GT9_REG_SEN_ORD - GT9_REG_CFG_BEG + i];
	}

	memset(cfg_drv_order, 0xFF, MAX_DRIVER_NUM);
	for (i = 0; i < drv_num; ++i)
	{
		cfg_drv_order[i] = config[GTP_ADDR_LENGTH + GT9_REG_DRV_ORD - GT9_REG_CFG_BEG + i];
	}

	return SUCCESS;
}

/*
 * @param:
 *      phy_chnl: ic detected short channel, is_driver: it's driver or not
 * @Return:
 *      0xff: the ic channel is not used, otherwise: the tp short channel
 */
u8 gt9_get_short_tp_chnl(u8 phy_chnl, u8 is_driver)
{
	u8 i = 0;
	if (is_driver)
	{
		for (i = 0; i < MAX_DRIVER_NUM; ++i)
		{
			if (cfg_drv_order[i] == phy_chnl)
			{
				return i;
			}
			else if (cfg_drv_order[i] == 0xff)
			{
				return 0xff;
			}
		}
	}
	else
	{
		for (i = 0; i < MAX_SENSOR_NUM; ++i)
		{
			if (cfg_sen_order[i] == phy_chnl)
			{
				return i;
			}
			else if (cfg_sen_order[i] == 0xff)
			{
				return 0xff;
			}
		}
	}
	return 0xff;
}


u8 gt9xx_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
{
	s32 i = 0;
	u8 msg[3];

	msg[0] = (addr >> 8) & 0xff;
	msg[1] = addr & 0xff;
	msg[2] = val;

	for (i = 0; i < 5; i++)
	{
		if (gtp_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
		{
			break;
		}
	}

	if (i >= 5)
	{
		GTP_ERROR("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
		return FAIL;
	}

	return SUCCESS;
}

static s32 gtp_i2c_end_cmd(struct i2c_client *client)
{
	u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
	s32 ret = 0;

	ret = gtp_i2c_write(client, end_cmd, 3);
	if (ret < 0)
	{
		SET_INFO_LINE_INFO("I2C write end_cmd  error!");
	}
	return ret;
}

s32 gtp_parse_config(void)
{
#if GTP_HAVE_TOUCH_KEY
	u8 i = 0;
	u8 key_pos = 0;
#endif
	int j = 0;
	struct goodix_ts_data *ts;
	u8 chksum = 0;
	u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};
	int ret, retry;

	if (gtp_i2c_read(i2c_connect_client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
	{
		SET_INFO_LINE_ERR("Failed to read config!");
		return FAIL;
	}
	// disable hopping
	if ((config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] & 0x80) ||
			config[GTP_ADDR_LENGTH + 11] & 0x1F)
	{
		GTP_INFO("Disable hopping, send test config"); // add by leo
		config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] &= 0x7F;
		config[GTP_ADDR_LENGTH + 11] &= 0x1F;
		ts = i2c_get_clientdata(i2c_connect_client);
		// calculate checksum
		for (j = 0; j < (ts->gtp_cfg_len-2); ++j)
		{
			chksum += config[GTP_ADDR_LENGTH + j];
		}
		config[ts->gtp_cfg_len] = (~chksum) + 1;
		config[ts->gtp_cfg_len+1] = 0x01;

		ret = gtp_i2c_write(i2c_connect_client, config,
				GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
		if (ret <= 0)
			return FAIL;

		retry = 60; /* timeout: 60 * 5ms = 300ms */
		do {
			u8 buffer[3] = {0x81, 0x00, 0x00}; /* reg 0x8100 */
			/* value of reg 0x8100 will indicate the update result
			 * of configuration data, if equals 0x00, it means the
			 * configuraton data is accepted by the firmware.
			 */
			ret = gtp_i2c_read(i2c_connect_client, buffer,
					sizeof(buffer));
			if (ret > 0 && buffer[2] == 0x00)
				break;
			usleep_range(5000, 5050);
		} while(retry--);

		if (retry == 0)
			GTP_ERROR("Wait test config been updated timeout");
		else
			GTP_INFO("Test config updated");
	}

	gt9xx_drv_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT-GT9_REG_CFG_BEG] & 0x1F)
	                + (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+1 -GT9_REG_CFG_BEG] & 0x1F);
	gt9xx_sen_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG] & 0x0F)
	                + ((config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG]>>4) & 0x0F);

	// add by leo for test ++
	gt9xx_drv_num = 40;
	gt9xx_sen_num = 27;

	GTP_INFO("gt9xx_drv_num = %d", gt9xx_drv_num);
	GTP_INFO("gt9xx_sen_num = %d", gt9xx_sen_num);
	// add by leo for test --

	if (gt9xx_drv_num < MIN_DRIVER_NUM || gt9xx_drv_num > MAX_DRIVER_NUM)
	{
		SET_INFO_LINE_ERR("driver number error!");
		return FAIL;
	}
	if (gt9xx_sen_num < MIN_SENSOR_NUM || gt9xx_sen_num > MAX_SENSOR_NUM)
	{
		SET_INFO_LINE_ERR("sensor number error!");
		return FAIL;
	}
	gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt = gt9xx_drv_num * gt9xx_sen_num;

	GTP_INFO("gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt = %d",gt9xx_sc_pxl_cnt); //add by leo if device with key then gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt -1

#if GTP_HAVE_TOUCH_KEY
	gt9xx_sc_drv_num = gt9xx_drv_num - (config[0x804E - GT9_REG_CFG_BEG + GTP_ADDR_LENGTH] & 0x01);

	key_is_isolated = 0;
	key_iso_pos[0] = 0;
	for (i = 0; i < 4; ++i)
	{
		key_pos = config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i]%0x08;
		GTP_DEBUG("key_val[%d] = 0x%x", i+1, config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i]);
		if (key_pos != 0)
		{
			break;
		}
		else
		{
			key_iso_pos[0]++;
			key_iso_pos[i+1] = config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i]/8;
		}
	}
	if (i == 4)
	{
		key_is_isolated = 1;
	}
	gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt - (gt9xx_drv_num-gt9xx_sc_drv_num) * gt9xx_sen_num;
	GTP_DEBUG("drv num: %d, sen num: %d, sc drv num: %d", gt9xx_drv_num, gt9xx_sen_num, gt9xx_sc_drv_num);
	if (key_is_isolated)
	{
		GTP_DEBUG("[%d key(s)]: %d, %d, %d, %d", key_iso_pos[0], key_iso_pos[1], key_iso_pos[2], key_iso_pos[3], key_iso_pos[4]);
	}
#endif

	return SUCCESS;
}

/*
 * Function:
 * 		write one byte to specified register
 * Input:
 * 		reg: the register address
 * 		val: the value to write into
 * Return:
 * 		i2c_write function return
 */
s32 gtp_write_register(struct i2c_client * client, u16 reg, u8 val)
{
	u8 buf[3];
	buf[0] = (u8) (reg >> 8);
	buf[1] = (u8) reg;
	buf[2] = val;
	return gtp_i2c_write(client, buf, 3);
}
/*
 * Function:
 * 		read one byte from specified register into buf
 * Input:
 *		reg: the register
 * 		buf: the buffer for one byte
 * Return:
 *		i2c_read function return
 */
s32 gtp_read_register(struct i2c_client * client, u16 reg, u8* buf)
{
	buf[0] = (u8)(reg >> 8);
	buf[1] = (u8)reg;
	return gtp_i2c_read(client, buf, 3);
}

/*
 * Function:
 * 		burn dsp_short code
 * Input:
 * 		i2c_client
 * Return:
 * 		SUCCESS: burning succeed, FAIL: burning failed
 */
s32 gtp_burn_dsp_short(struct i2c_client *client)
{
	s32 ret = 0;
	u8 *opr_buf;
	u16 i = 0;
	u16 addr = GTP_REG_DSP_SHORT;
	u16 opr_len = 0;
	u16 left = 0;

	GTP_DEBUG("Start writing dsp_short code");
	opr_buf = (u8*)kmalloc(sizeof(u8) * (sizeof(dsp_short)+2), GFP_KERNEL);
	if (!opr_buf)
	{
		SET_INFO_LINE_ERR("failed to allocate memory for check buffer!");
		return FAIL;
	}

	left = sizeof(dsp_short);
	while (left > 0)
	{
		opr_buf[0] = (u8)(addr >> 8);
		opr_buf[1] = (u8)(addr);
		if (left > 2048)
		{
			opr_len = 2048;
		}
		else
		{
			opr_len = left;
		}
		memcpy(&opr_buf[2], &dsp_short[addr-GTP_REG_DSP_SHORT], opr_len);
		ret = gtp_i2c_write(client, opr_buf, 2 + opr_len);
		if ( ret < 0 )
		{
			SET_INFO_LINE_ERR("write dsp_short code failed!");
			kfree(opr_buf);
			return FAIL;
		}
		addr += opr_len;
		left -= opr_len;
	}

	// check code: 0xC000~0xCFFF
	GTP_DEBUG("Start checking dsp_short code");
	addr = GTP_REG_DSP_SHORT;
	left = sizeof(dsp_short);
	while (left > 0)
	{
		opr_buf[0] = (u8)(addr >> 8);
		opr_buf[1] = (u8)(addr);

		msleep(20);

		if (left > 2048)
		{
			opr_len = 2048;
		}
		else
		{
			opr_len = left;
		}

		ret = gtp_i2c_read(client, opr_buf, opr_len+2);
		if (ret < 0)
		{
			kfree(opr_buf);
			return FAIL;
		}
		for (i = 0; i < opr_len; ++i)
		{
#if 0
			if((i!=0)&&(i%16==0))
			{
				printk("\n");
			}
			printk("0x%02x ",opr_buf[i+2]);
#endif

			if (opr_buf[i+2] != dsp_short[addr-GTP_REG_DSP_SHORT+i])
			{
				SET_INFO_LINE_ERR("check dsp_short code failed!");
				//SET_INFO_LINE_ERR("opr_buf[%d] = 0x%02x, dsp_short[%d]",i+2,opr_buf[i+2],addr-GTP_REG_DSP_SHORT+i,dsp_short[addr-GTP_REG_DSP_SHORT+i]);
				kfree(opr_buf);
				return FAIL;
			}
		}
		addr += opr_len;
		left -= opr_len;
	}

	kfree(opr_buf);
	return SUCCESS;
}
/*
 * Function:
 * 		check the resistor between shortlike channels if less than threshold confirm as short
 * INPUT:
 *		Short like Information struct pointer
 * Returns:
 *		SUCCESS: it's shorted FAIL: otherwise
 */
s32 gtp_short_resist_check(struct gt9xx_short_info *short_node)
{
	s32 short_resist = 0;
	struct gt9xx_short_info *node = short_node;
	u8 master = node->master;
	u8 slave = node->slave;
	u8 chnnl_tx[4] = { GT9_DRV_HEAD|13, GT9_DRV_HEAD|28,
	                   GT9_DRV_HEAD|29, GT9_DRV_HEAD|42
	                 };
	s32 numberator = 0;
	u32 amplifier = 1000;  // amplify 1000 times to emulate float computing


	// Tx-ABIST & Tx_ABIST
	if ((((master > chnnl_tx[0]) && (master <= chnnl_tx[1])) &&
	        ((slave > chnnl_tx[0]) && (slave <= chnnl_tx[1])) ) ||
	        (((master > chnnl_tx[2]) && (master <= chnnl_tx[3])) &&
	         ((slave > chnnl_tx[2]) && (master <= chnnl_tx[3]))))
	{
		numberator = node->self_data * 40 * amplifier;
		short_resist = numberator/(node->short_code) - 40 * amplifier;
	}
	// Receiver is Rx-odd(1,3,5)
	else if ((node->slave & (GT9_DRV_HEAD | 0x01)) == 0x01)
	{
		numberator = node->self_data * 60 * amplifier;
		short_resist = numberator/node->short_code - 40 * amplifier;
	}
	else
	{
		numberator = node->self_data * 60 * amplifier;
		short_resist = numberator / node->short_code - 60 * amplifier;
	}
	GTP_DEBUG("self_data = %d" ,node->self_data);
	GTP_DEBUG("master = 0x%x, slave = 0x%x", node->master, node->slave);
	GTP_DEBUG("short_code = %d, short_resist = %d", node->short_code, short_resist);

	if (short_resist < 0)
	{
		short_resist = 0;
	}

	if (short_resist < (gt900_resistor_threshold * amplifier))
	{
		node->impedance = short_resist / amplifier;
		return SUCCESS;
	}
	else
	{
		return FAIL;
	}
}



/*
 * Function:
 * 		compute the result, whether there are shorts or not
 * Input:
 * 		i2c_client
 * Return:
 * 		SUCCESS
 */
s32 gtp_compute_rslt(struct i2c_client *client)
{
	u16 short_code;
	u8 i = 0, j = 0;
	u16 result_addr;
	u8 *result_buf;
	u16 *self_data;
	s32 ret = 0;
	u16 data_len = 3 + (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2 + 2; // a short data frame length
	struct gt9xx_short_info short_node;
	u16 node_idx = 0; // short_sum index: 0~GT9_INFO_NODE_MAX

	u8 tx_short_num = 0;
	u8 rx_short_num = 0;

	u8 master, slave;

	self_data = (u16*)kmalloc(sizeof(u16) * ((MAX_DRIVER_NUM + MAX_SENSOR_NUM)), GFP_KERNEL);
	if (!self_data) {
		SET_INFO_LINE_ERR("allocate memory for short result failed!");
		return FAIL;
	}

	result_buf = (u8*)kmalloc(sizeof(u8) * (data_len+2), GFP_KERNEL);
	if (!result_buf) {
		SET_INFO_LINE_ERR("allocate memory for short result failed!");
		kfree(self_data);
		return FAIL;
	}

	short_sum = (struct gt9xx_short_info *) kmalloc(sizeof(struct gt9xx_short_info) * GT9_INFO_NODE_MAX, GFP_KERNEL);
	if (!short_sum) {
		SET_INFO_LINE_ERR("allocate memory for short result failed!");
		kfree(self_data);
		kfree(result_buf);
		return FAIL;
	}

	// Get Selfdata
	result_buf[0] = 0xA4;
	result_buf[1] = 0xA1;
	gtp_i2c_read(client, result_buf, 2 + 144);
	for (i = 0, j = 0; i < 144; i += 2)
	{
		self_data[j++] = (u16)(result_buf[i] << 8) + (u16)(result_buf[i+1]);
	}
	GTP_DEBUG("Self Data:");
	GTP_DEBUG_ARRAY(result_buf+2, 144);


	// Get TxShortNum & RxShortNum
	result_buf[0] = 0x88;
	result_buf[1] = 0x02;
	gtp_i2c_read(client, result_buf, 2 + 2);
	tx_short_num = result_buf[2];
	rx_short_num = result_buf[3];

	GTP_DEBUG("Tx Short Num: %d, Rx Short Num: %d", tx_short_num, rx_short_num);

	//
	result_addr = 0x8860;
	data_len = 3 + (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2 + 2;
	for (i = 0; i < tx_short_num; ++i)
	{
		result_buf[0] = (u8) (result_addr >> 8);
		result_buf[1] = (u8) (result_addr);
		ret = gtp_i2c_read(client, result_buf, data_len+2);
		if (ret < 0)
		{
			SET_INFO_LINE_ERR("read result data failed!");
		}
		GTP_DEBUG("Result Buffer: ");
		GTP_DEBUG_ARRAY(result_buf+2, data_len);

		short_node.master_is_driver = 1;
		short_node.master = result_buf[2];

		// Tx - Tx
		for (j = i + 1; j < MAX_DRIVER_NUM; ++j)
		{
			short_code = (result_buf[2+3+j*2] << 8) + result_buf[2+3+j*2+1];
			if (short_code > gt900_short_threshold)
			{
				short_node.slave_is_driver = 1;
				short_node.slave = ChannelPackage_TX[j] | GT9_DRV_HEAD;
				short_node.self_data = self_data[j];
				short_node.short_code = short_code;

				ret = gtp_short_resist_check(&short_node);
				if (ret == SUCCESS)
				{
					if (node_idx < GT9_INFO_NODE_MAX)
					{
						short_sum[node_idx++] = short_node;
					}
				}
			}
		}
		// Tx - Rx
		for (j = 0; j < MAX_SENSOR_NUM; ++j)
		{
			short_code = (result_buf[2+3+84+j*2] << 8) + result_buf[2+3+84+j*2+1];

			if (short_code > gt900_short_threshold)
			{
				short_node.slave_is_driver = 0;
				short_node.slave = j | GT9_SEN_HEAD;
				short_node.self_data = self_data[MAX_DRIVER_NUM + j];
				short_node.short_code = short_code;

				ret = gtp_short_resist_check(&short_node);
				if (ret == SUCCESS)
				{
					if (node_idx < GT9_INFO_NODE_MAX)
					{
						short_sum[node_idx++] = short_node;
					}
				}
			}
		}

		result_addr += data_len;
	}

	result_addr = 0xA0D2;
	data_len = 3 + MAX_SENSOR_NUM * 2 + 2;
	for (i = 0; i < rx_short_num; ++i)
	{
		result_buf[0] = (u8) (result_addr >> 8);
		result_buf[1] = (u8) (result_addr);
		ret = gtp_i2c_read(client, result_buf, data_len + 2);
		if (ret < 0)
		{
			SET_INFO_LINE_ERR("read result data failed!");
		}

		GTP_DEBUG("Result Buffer: ");
		GTP_DEBUG_ARRAY(result_buf+2, data_len);

		short_node.master_is_driver = 0;
		short_node.master = result_buf[2];

		// Rx - Rx
		for (j = 0; j < MAX_SENSOR_NUM; ++j)
		{
			if ((j == i) || ( (j < i) && (j & 0x01) == 0))
			{
				continue;
			}
			short_code = (result_buf[2+3+j*2] << 8) + result_buf[2+3+j*2+1];

			if (short_code > gt900_short_threshold)
			{
				short_node.slave_is_driver = 0;
				short_node.slave = j | GT9_SEN_HEAD;
				short_node.self_data = self_data[MAX_DRIVER_NUM + j];
				short_node.short_code = short_code;

				ret = gtp_short_resist_check(&short_node);
				if (ret == SUCCESS)
				{
					if (node_idx < GT9_INFO_NODE_MAX)
					{
						short_sum[node_idx++] = short_node;
					}
				}
			}
		}

		result_addr += data_len;
	}

	if (node_idx == 0)
	{
		ret = SUCCESS;
	}
	else
	{
		for (i = 0, j = 0; i < node_idx; ++i)
		{
			if ((short_sum[i].master_is_driver))
			{
				if (short_sum[i].master > (26 | GT9_DRV_HEAD))
				{
					short_sum[i].master--;
				}
				master = gt9_get_short_tp_chnl(short_sum[i].master-GT9_DRV_HEAD, 1);

			}
			else
			{
				master = gt9_get_short_tp_chnl(short_sum[i].master, 0);
			}

			if ((short_sum[i].slave_is_driver))
			{
				if (short_sum[i].slave > (26 | GT9_DRV_HEAD))
				{
					short_sum[i].slave--;
				}
				slave = gt9_get_short_tp_chnl(short_sum[i].slave-GT9_DRV_HEAD, 1);

			}
			else
			{
				slave = gt9_get_short_tp_chnl(short_sum[i].slave, 0);
			}
			GTP_DEBUG("Orignal Shorted Channels: %s%d, %s%d",
			          (short_sum[i].master_is_driver) ? "Drv" : "Sen", master,
			          (short_sum[i].slave_is_driver) ? "Drv" : "Sen", slave);

			if (master == 255 && slave == 255)
			{
				GTP_DEBUG("unbonded channel (%d, %d) shorted!", short_sum[i].master, short_sum[i].slave);
				continue;
			}
			else
			{
				short_sum[j].slave = slave;
				short_sum[j].master = master;
				short_sum[j].slave_is_driver = short_sum[i].slave_is_driver;
				short_sum[j].master_is_driver = short_sum[i].master_is_driver;
				short_sum[j].impedance = short_sum[i].impedance;
				short_sum[j].self_data = short_sum[i].self_data;
				short_sum[j].short_code = short_sum[i].short_code;
				++j;
			}
		}
		node_idx = j;
		if (node_idx == 0)
		{
			ret = SUCCESS;
		}
		else
		{
			for (i = 0; i < node_idx; ++i)
			{
				SET_INFO_LINE_INFO("  %s%02d & %s%02d Shorted! (R = %dKOhm)",
				                   (short_sum[i].master_is_driver) ? "Drv" : "Sen", short_sum[i].master,
				                   (short_sum[i].slave_is_driver) ? "Drv" : "Sen", short_sum[i].slave,
				                   short_sum[i].impedance);
			}
			ret = FAIL;
		}
	}

	kfree(self_data);
	kfree(short_sum);
	kfree(result_buf);
	return ret;
}

s32 gt9_test_gnd_vdd_short(struct i2c_client *client)
{

	u8 *data;
	s32 ret = 0;
	s32 i = 0;
	u16 len = (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2;
	u16 short_code = 0;
	s32 r = -1;
	u32 short_res = 0;
	u16 amplifier = 1000;

	data = (u8 *)kmalloc(sizeof(u8) * (len + 2), GFP_KERNEL);
	if (NULL == data)
	{
		SET_INFO_LINE_ERR("failed to allocate memory for gnd vdd test data buffer");
		return FAIL;
	}

	data[0] = 0xA5;
	data[1] = 0x31;
	gtp_i2c_read(client, data, 2 + len);

	GTP_DEBUG_ARRAY(data+2, len);
	ret = SUCCESS;
	for (i = 0; i < len; i += 2)
	{
		short_code = (data[2+i] << 8) + (data[2 + i + 1]);
		if (short_code == 0)
		{
			continue;
		}
		if ((short_code & 0x8000) == 0)        // short with GND
		{
#ifdef GTP_SHORT_GND
			r = 5266285 * 10 / (short_code & (~0x8000)) - 40 * amplifier;
#endif
		}
		else    // short with VDD
		{
			//r = ( 1/(((float)(short_code&(~0x8000)))/0.9*0.7/1024/(sys.avdd-0.9)/40) ) -40;
#ifdef GTP_VDD
			r = 40*9*1024*(100*GTP_VDD - 900)/((short_code&(~0x8000))*7) - 40*1000;
			GTP_DEBUG("vdd short_code: %d", short_code & (~0x8000));
#endif
		}
		GTP_DEBUG("resistor: %d, short_code: %d", r, short_code);

		short_res = (r >= 0) ? r : 0xFFFF;
		if (short_res == 0xFFFF)
		{
		}
		else
		{
			if (short_res < (gt900_gnd_resistor_threshold * amplifier))
			{
				if (i < MAX_DRIVER_NUM * 2)       // driver
				{
					SET_INFO_LINE_INFO("  Drv%02d & GND/VDD Shorted! (R = %dKOhm)", ChannelPackage_TX[i/2], short_res/amplifier);
				}
				else
				{
					SET_INFO_LINE_INFO("  Sen%02d & GND/VDD Shorted! (R = %dKOhm)", (i/2) - MAX_DRIVER_NUM, short_res/amplifier);
				}
				ret = FAIL;
			}
		}
	}
	kfree(data);
	return ret;
}


/*
 * leave short test
 */
void gt9xx_leave_short_test(struct i2c_client *client)
{
	// boot from rom and download code from flash to ram
	gtp_write_register(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
	gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x08);

	gtp_reset_guitar(client, 20);
	msleep(100);

	gtp_send_cfg(client);
	msleep(300);
	SET_INFO_LINE_INFO("");
	SET_INFO_LINE_INFO("---gtp short test end---");

	return;
}


/*
 * Function:
 *		gt9 series ic short test function
 * Input:
 * 		I2c_client, i2c device
 * Return:
 * 		SUCCESS: test succeed, FAIL: test failed
 */
s32 gt9xx_short_test(struct i2c_client * client)
{
	s32 ret = 0;
	s32 ret2 = 0;
	u8 i = 0;
	u8 opr_buf[60] = {0};
	u8 retry = 0;
	u8 drv_sen_chksum = 0;
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(i2c_connect_client);
	//gtp_irq_disable(ts);
	disable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 1;     // suspend esd
#endif
	// step 1: reset guitar, delay 1ms,  hang up ss51 and dsp
	SET_INFO_LINE_INFO("---gtp short test---");
	SET_INFO_LINE_INFO("Step 1: reset guitar, hang up ss51 dsp");

	gt9xx_short_parse_cfg();

	// RST output low last at least 2ms
	GTP_GPIO_OUTPUT(ts->pdata->reset_gpio, 0);
	msleep(2);

	// select I2C slave addr,INT:0--0xBA;1--0x28.
	GTP_GPIO_OUTPUT(ts->pdata->irq_gpio, (client->addr == 0x14));
	msleep(2);

	// RST output high reset guitar
	GTP_GPIO_OUTPUT(ts->pdata->reset_gpio, 1);

	while(retry++ < 200)
	{
		// Hold ss51 & dsp
		ret = gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
		if(ret <= 0)
		{
			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
			gtp_reset_guitar(client, 10);
			continue;
		}

		// Confirm hold
		ret = gtp_read_register(client, _rRW_MISCTL__SWRST_B0_, opr_buf);
		if(ret <= 0)
		{
			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
			gtp_reset_guitar(client, 10);
			continue;
		}
		if(0x0C == opr_buf[GTP_ADDR_LENGTH])
		{
			GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
			break;
		}
		GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", opr_buf[GTP_ADDR_LENGTH]);
	}
	if(retry >= 200)
	{
		GTP_ERROR("Enter update Hold ss51 failed.");
		return FAIL;
	}
	// DSP_CK and DSP_ALU_CK PowerOn
	gtp_write_register(client, 0x4010, 0x00);
	SET_INFO_LINE_INFO("Enter short test mode SUCCESS.");

	// step2: burn dsp_short code
	SET_INFO_LINE_INFO("Step 2: burn dsp_short code");
	gtp_write_register(client, _bRW_MISCTL__TMR0_EN, 0x00); // clear watchdog
	gtp_write_register(client, _bRW_MISCTL__CACHE_EN, 0x00); // clear cache
	gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02); // boot from sram
	gtp_write_register(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01); // reset software
	gtp_write_register(client, _bRW_MISCTL__SRAM_BANK, 0x00); // select bank 0
	gtp_write_register(client, _bRW_MISCTL__MEM_CD_EN, 0x01); // allow AHB bus accessing code sram

	// ---: burn dsp_short code
	retry=0;
	while(retry < 3)
	{
		SET_INFO_LINE_INFO("		retry time: %d", retry);
		ret = gtp_burn_dsp_short(client);
		if ((ret == FAIL)&&(retry==2))
		{
			SET_INFO_LINE_ERR("Step 2: burn dsp_short failed!");
			goto short_test_exit;

		}
		else if(ret==SUCCESS)
		{
			SET_INFO_LINE_INFO("Step 2: burn dsp_short success!");
			break;
		}
		SET_INFO_LINE_ERR("burn dsp_short failed!try again!");
		retry++;
	}
	/*
	ret = gtp_burn_dsp_short(client);
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("step2: burn dsp_short failed!");
		goto short_test_exit;
	}
	*/
	// step3: run dsp_short, read results
	SET_INFO_LINE_INFO("Step 3: run dsp_short code, confirm it's runnin'");
	gtp_write_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, 0x00);	// clear dsp_short running flag
	gtp_write_register(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x03);//set scramble

	ret = gt9xx_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);           //20121114
	gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x08);	// release dsp

	msleep(80);
	// confirm dsp is running
	i = 0;
	while (1)
	{
		opr_buf[2] = 0x00;
		gtp_read_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, opr_buf);
		if (opr_buf[2] == 0xAA)
		{
			break;
		}
		++i;
		if (i >= 8)
		{
			SET_INFO_LINE_ERR("Step 3: dsp is not running!");
			goto short_test_exit;
		}
		msleep(10);
	}
	// step4: host configure ic, get test result
	SET_INFO_LINE_INFO("Step 4: host config ic, get test result");
	// Short Threshold
	GTP_DEBUG(" Short Threshold: %d", gt900_short_threshold);
	opr_buf[0] = (u8) (GTP_REG_SHORT_TH >> 8);
	opr_buf[1] = (u8) GTP_REG_SHORT_TH;
	opr_buf[2] = (u8)(gt900_short_threshold >> 8);
	opr_buf[3] = (u8)(gt900_short_threshold & 0xFF);
	gtp_i2c_write(client, opr_buf, 4);

	// ADC Read Delay
	GTP_DEBUG(" ADC Read Delay: %d", gt900_adc_read_delay);
	opr_buf[1] += 2;
	opr_buf[2] = (u8)(gt900_adc_read_delay >> 8);
	opr_buf[3] = (u8)(gt900_adc_read_delay & 0xFF);
	gtp_i2c_write(client, opr_buf, 4);

	// DiffCode Short Threshold
	GTP_DEBUG(" DiffCode Short Threshold: %d", gt900_diffcode_short_threshold);
	opr_buf[0] = 0x88;
	opr_buf[1] = 0x51;
	opr_buf[2] = (u8)(gt900_diffcode_short_threshold >> 8);
	opr_buf[3] = (u8)(gt900_diffcode_short_threshold & 0xFF);
	gtp_i2c_write(client, opr_buf, 4);

	// Config Driver & Sensor Order
#if GTP_DEBUG_ON
	printk("<<-GTP-DEBUG->>: Driver Map:\n");
	printk("IC Driver:");
	for (i = 0; i < MAX_DRIVER_NUM; ++i)
	{
		printk(" %d", cfg_drv_order[i]);
	}
	printk("\n");
	printk("TP Driver:");
	for (i = 0; i < MAX_DRIVER_NUM; ++i)
	{
		printk(" %d", i);
	}
	printk("\n");

	printk("<<-GTP-DEBUG->>: Sensor Map:\n");
	printk("IC Sensor:");
	for (i = 0; i < MAX_SENSOR_NUM; ++i)
	{
		printk(" %d", cfg_sen_order[i]);
	}
	printk("\n");
	printk("TP Sensor:");
	for (i = 0; i < MAX_SENSOR_NUM; ++i)
	{
		printk(" %d", i);
	}
	printk("\n");
#endif

	opr_buf[0] = 0x88;
	opr_buf[1] = 0x08;
	for (i = 0; i < MAX_DRIVER_NUM; ++i)
	{
		opr_buf[2 + i] = cfg_drv_order[i];
		drv_sen_chksum += cfg_drv_order[i];
	}
	gtp_i2c_write(client, opr_buf, MAX_DRIVER_NUM + 2);

	opr_buf[0] = 0x88;
	opr_buf[1] = 0x32;
	for (i = 0; i < MAX_SENSOR_NUM; ++i)
	{
		opr_buf[2+i] = cfg_sen_order[i];
		drv_sen_chksum += cfg_sen_order[i];
	}
	gtp_i2c_write(client, opr_buf, MAX_SENSOR_NUM + 2);

	opr_buf[0] = 0x88;
	opr_buf[1] = 0x50;
	opr_buf[2] = drv_sen_chksum;
	gtp_i2c_write(client, opr_buf, 2 + 1);

	// clear waiting flag, run dsp
	gtp_write_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, 0x04);

	// inquirying test status until it's okay
	for (i = 0;; ++i)
	{
		gtp_read_register(client, 0x8800, opr_buf);
		if (opr_buf[2] == 0x88)
		{
			break;
		}
		msleep(50);
		if ( i > 100 )
		{
			SET_INFO_LINE_ERR("step 4: inquiry test status timeout!");
			goto short_test_exit;
		}
	}

	// step 5: compute the result
	/* short flag:
	      bit0: Rx & Rx
	      bit1: Tx & Tx
	      bit2: Tx & Rx
	      bit3: Tx/Rx & GND/VDD
	*/
	gtp_read_register(client, 0x8801, opr_buf);
	GTP_DEBUG("short_flag = 0x%x", opr_buf[2]);
	SET_INFO_LINE_INFO("");
	SET_INFO_LINE_INFO("Short Test Result:");
	if ((opr_buf[2] & 0x0f) == 0)
	{
		SET_INFO_LINE_INFO("PASS!");
		ret = SUCCESS;
	}
	else
	{
		if ((opr_buf[2] & 0x08) == 0x08)
		{
			ret2 = gt9_test_gnd_vdd_short(client);

		}
		ret = gtp_compute_rslt(client);
		if (ret == SUCCESS && ret2 == SUCCESS)
		{
			SET_INFO_LINE_INFO("PASS!");
		}
	}
	gt9xx_leave_short_test(client);
	//gtp_irq_enable(ts);
	enable_irq(ts->client->irq);

#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 0;     // resume esd
#endif
	test_result=ret; // add by leo for ATD
	return ret;

short_test_exit:
	gt9xx_leave_short_test(client);
	//gtp_irq_enable(ts);
	enable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 0;     // resume esd
#endif
	test_result=FAIL; // add by leo for ATD
	return FAIL;
}

u32 endian_mode(void)
{
	union
	{
		s32 i;
		s8 c;
	} endian;

	endian.i = 1;

	if (1 == endian.c)
	{
		return MYBIG_ENDIAN;
	}
	else
	{
		return MYLITLE_ENDIAN;
	}
}
/*
*********************************************************************************************************
* Function:
*	send read rawdata cmd
* Input:
*	i2c_client* client: i2c device
* Return:
* 	SUCCESS: send process succeed, FAIL: failed
*********************************************************************************************************
*/
s32 gt9_read_raw_cmd(struct i2c_client* client)
{
	u8 raw_cmd[3] = {(u8)(GTP_REG_READ_RAW >> 8), (u8)GTP_REG_READ_RAW, 0x01};
	s32 ret = -1;

	ret = gtp_i2c_write(client, raw_cmd, 3);
	if(ret <= 0)
	{
		SET_INFO_LINE_ERR("i2c write failed.");
		return FAIL;
	}
	msleep(58);
	return SUCCESS;
}

s32 gt9_read_coor_cmd(struct i2c_client *client)
{
	u8 raw_cmd[3] = {(u8)(GTP_REG_READ_RAW >> 8), (u8)GTP_REG_READ_RAW, 0x0};
	s32 ret = -1;

	ret = gtp_i2c_write(client, raw_cmd, 3);
	if (ret < 0)
	{
		SET_INFO_LINE_ERR("i2c write coor cmd failed!");
		return FAIL;
	}
	msleep(10);
	return SUCCESS;
}
/*
*********************************************************************************************************
* Function:
*	read rawdata from ic registers
* Input:
*	u16* data: rawdata buffer
* 	i2c_client* client: i2c device
* Return:
* 	SUCCESS: read process succeed, FAIL:  failed
*********************************************************************************************************
*/
static u16 real_raw_data[TOTAL_PIXEL_NUM]= {0};

s32 gtp_read_rawdata(struct i2c_client* client, u16* data)
{
	s32 ret = -1;
	u16 retry = 0;
	//u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
	u8 read_state[3] = {(u8)(GTP_REG_RAW_READY>>8), (u8)GTP_REG_RAW_READY, 0};
	u16 i = 0, j = 0, k = 0;
	u8 *read_rawbuf;
	u8 tail, head;
	//u16 real_raw_data[TOTAL_PIXEL_NUM]= {0}; // add by leo

	read_rawbuf = (u8*)kmalloc(sizeof(u8) * (gt9xx_pixel_cnt * 2 + GTP_ADDR_LENGTH), GFP_KERNEL);
	if (NULL == read_rawbuf)
	{
		SET_INFO_LINE_ERR("failed to allocate for read_rawbuf");
		return FAIL;
	}
	read_rawbuf[0] = (u8)( GTP_REG_RAW_DATA >> 8);
	read_rawbuf[1] = (u8)( GTP_REG_RAW_DATA );

	if(data == NULL)
	{
		SET_INFO_LINE_ERR("Invalid raw buffer.");
		goto have_error;
	}

	msleep(10);
	while (retry++ < GTP_WAIT_RAW_MAX_TIMES)
	{
		ret = gtp_i2c_read(client, read_state, 3);
		if(ret <= 0)
		{
			SET_INFO_LINE_ERR("i2c read failed.return: %d", ret);
			continue;
		}
		if(read_state[GTP_ADDR_LENGTH] == 0x80)
		{
			GTP_DEBUG("Raw data is ready.");
			break;
		}
		else
			GTP_INFO("read_state[GTP_ADDR_LENGTH] = 0x%02X", read_state[GTP_ADDR_LENGTH]);

		if ((retry % 10) == 0)
		{
			GTP_DEBUG("read_state[2] = 0x%x", read_state[GTP_ADDR_LENGTH]);
		}
		msleep(5);
	}
	if (retry >= GTP_WAIT_RAW_MAX_TIMES)
	{
#if 0
		SET_INFO_LINE_ERR("Wait raw data ready timeout.");
		goto have_error;

#else
		gtp_reset_guitar(client, 20);  //reset touch IC
		msleep(300);
		SET_INFO_LINE_ERR("Reset touch IC and into raw mode.");

		//ret = gtp_parse_config();
		//if (ret == FAIL)
		//	SET_INFO_LINE_ERR("Send test config timeout");

		/* clear the first three sync pulse */
		for (i = 0; i < 3; i++) {
			int retry = 10;
			u8 state[3] = {(u8)(GTP_REG_RAW_READY>>8), (u8)GTP_REG_RAW_READY, 0};
			do {
				ret = gtp_i2c_read(client, &state[0], sizeof(state));
				if (ret <= 0 || (state[2] & 0x80) == 0x00){
					usleep_range(5000, 5050); /* 5ms */
					continue;
				}
				gtp_i2c_end_cmd(client);
				break;
			} while (retry--);
			if ((state[2] & 0x80) == 0x00) {
				GTP_INFO("Clear sync pulse %u timeout", i);
				break; /* timeout */
			}
		}
		msleep(100);

		ret = gt9_read_raw_cmd(client); // change to raw data mode again
		if (ret == FAIL)
		{
			SET_INFO_LINE_ERR("Send Read Rawdata Cmd failed!");
		}

		retry = 0;
		while (retry++ < GTP_WAIT_RAW_MAX_TIMES) // try to read raw data again
		{
			ret = gtp_i2c_read(client, read_state, 3);
			if(ret <= 0)
			{
				SET_INFO_LINE_ERR("i2c read failed.return: %d", ret);
				continue;
			}
			if(read_state[GTP_ADDR_LENGTH] == 0x80)
			{
				GTP_DEBUG("Raw data is ready.");
				break;
			}
			if ((retry % 10) == 0)
				GTP_DEBUG("read_state[2] = 0x%x", read_state[GTP_ADDR_LENGTH]);
			msleep(5);
		}
		if (retry >= GTP_WAIT_RAW_MAX_TIMES)
		{
			SET_INFO_LINE_ERR("Wait raw data ready timeout.");
			goto have_error;
		}
#endif
	}

	ret = gtp_i2c_read(client, read_rawbuf, GTP_ADDR_LENGTH + ((gt9xx_drv_num*gt9xx_sen_num)*2));
	if(ret <= 0)
	{
		SET_INFO_LINE_ERR("i2c read rawdata failed.");
		goto have_error;
	}
	gtp_i2c_end_cmd(client);	// clear buffer state

	if (endian_mode() == MYBIG_ENDIAN)
	{
		head = 0;
		tail =1;
		GTP_DEBUG("Big Endian.");
	}
	else
	{
		head = 1;
		tail = 0;
		GTP_DEBUG("Little Endian.");
	}

	for(i=0,j = 0; i < ((gt9xx_drv_num*gt9xx_sen_num)*2); i+=2)
	{
		real_raw_data[i/2] = (u16)(read_rawbuf[i+head+GTP_ADDR_LENGTH]<<8) + (u16)read_rawbuf[GTP_ADDR_LENGTH+i+tail];
#if GTP_DEBUG_ARRAY_ON
		GTP_DEBUG("%d ", data[i/2]);
		++j;
		if((j%gt9xx_drv_num) == 0)
			GTP_DEBUG("\n");
#endif
	}

	// Transfor raw data from 32x24 to 24x32
	for(i=0; i < gt9xx_drv_num ; i++)
	{
		for(j=0; j < gt9xx_drv_num*gt9xx_sen_num ; j+=gt9xx_sen_num,k++)
		{
			data[k]= real_raw_data[i+j];
			//printk("////////////////////		real_raw_data[%d]=%d\n",k,data[i+j]);
		}
		if(k==TOTAL_PIXEL_NUM)break;
	}

	kfree(read_rawbuf);
	return SUCCESS;
have_error:
	kfree(read_rawbuf);
	return FAIL;
}
/*
*********************************************************************************************************
* Function:
*	rawdata test initilization function
* Input:
*	u32 check_types: test items
*********************************************************************************************************
*/
static int gtp_raw_test_init(u32 check_types)
{
	u16 i = 0;

	test_rslt_buf = (s32*) kmalloc(sizeof(s32)*sample_set_num, GFP_ATOMIC);
	if (!test_rslt_buf) {
		SET_INFO_LINE_ERR("Test result buffer allocate failed!");
		return FAIL;
	}

	touchpad_sum = (struct gt9xx_open_info*) kmalloc(sizeof(struct gt9xx_open_info) * 4 * _BEYOND_REC_MAX, GFP_ATOMIC);
	if (touchpad_sum == NULL) {
		kfree(test_rslt_buf);
		test_rslt_buf = NULL;
		SET_INFO_LINE_ERR("Test result buffer allocate failed!");
		return FAIL;
	}

	memset(touchpad_sum, 0, sizeof(struct gt9xx_open_info) * 4 * _BEYOND_REC_MAX);
	for (i = 0; i < gt9xx_drv_num*gt9xx_sen_num; i++)
	{
		if (i < sample_set_num)
		{
			test_rslt_buf[i] = _CHANNEL_PASS;
		}
	}

	// add by leo for dynamic change limit value ++
	gt6108_raw_acc_spec = (struct gt9xx_tp_raw_acc_info*) kmalloc(sizeof(struct gt9xx_tp_raw_acc_info) * TOTAL_PIXEL_NUM, GFP_KERNEL);
	if (gt6108_raw_acc_spec == NULL) {
		kfree(test_rslt_buf);
		test_rslt_buf = NULL;
		kfree(touchpad_sum);
		touchpad_sum = NULL;
		SET_INFO_LINE_ERR("gt6108_raw_acc_spec buffer allocate failed!");
		return FAIL;
	}

	memset(gt6108_raw_acc_spec, 0, sizeof(struct gt9xx_tp_raw_acc_info) * TOTAL_PIXEL_NUM);
	// add by leo for dynamic change limit value --

	return SUCCESS;
}

/*
*********************************************************************************************************
* Function:
*	touchscreen rawdata min limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_min_test(u16 *raw_buf)
{
	u16 i=0, j=0, min_limit=0;
	u8 driver, sensor;
	u8 sum_base = 1 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		if(AbsoluteTotalCheck)
			min_limit=min_limit_value;
		else
			min_limit=gt6108_raw_acc_spec[i].min_rawdata;

		//if (raw_buf[i] < min_limit_value)
		//if (raw_buf[i] < gt6108_raw_acc_spec[i].min_rawdata)
		if (raw_buf[i] < min_limit)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_MIN_LIMIT;
			driver = (i/gt9xx_sen_num) + 1;
			sensor = (i%gt9xx_sen_num) + 1;
			new_flag = 0;
			for (j = sum_base; j < (sum_base+_BEYOND_REC_MAX); ++j)
			{
				if (touchpad_sum[j].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
				{
					touchpad_sum[j].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[j].driver = driver;
				touchpad_sum[j].sensor = sensor;
				touchpad_sum[j].beyond_type |= _BEYOND_MIN_LIMIT;
				touchpad_sum[j].raw_val = raw_buf[i];
				touchpad_sum[j].times = 1;
			}
			else
			{
				continue;
			}
			//GTP_DEBUG("[%d, %d]rawdata: %d, raw min limit: %d", driver, sensor, raw_buf[i], min_limit_value);
			//GTP_DEBUG("[%d, %d]rawdata: %d, raw min limit: %d", driver, sensor, raw_buf[i], gt6108_raw_acc_spec[i].min_rawdata);
			SET_INFO_LINE_INFO("[%s][%d, %d] rawdata: %d < raw min limit: %d", __FUNCTION__, driver, sensor, raw_buf[i], min_limit);
		}
	}
	return;
}

/*
*********************************************************************************************************
* Function:
*	touchscreen rawdata max limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_max_test(u16 *raw_buf)
{
	u16 i =0, j=0, max_limit=0;
	u8 driver, sensor;
	u8 sum_base = 0 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	printk("////////////////////		gtp_raw_max_test\n");

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		if(AbsoluteTotalCheck)
			max_limit=max_limit_value;
		else
			max_limit=gt6108_raw_acc_spec[i].max_rawdata;

		//printk("raw_buf[%d] =%d , max_rawdata[%d] = %d\n",i,raw_buf[i],i,gt6108_raw_acc_spec[i].max_rawdata);
		//printk("max_limit = %d\n",max_limit);

		gt6108_raw_data[i]=raw_buf[i];

		//if (raw_buf[i] > max_limit_value)
		//if (raw_buf[i] > gt6108_raw_acc_spec[i].max_rawdata)
		if (raw_buf[i] > max_limit)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_MAX_LIMIT;
			driver = (i/gt9xx_drv_num) + 1;
			sensor = (i%gt9xx_drv_num) + 1;
			new_flag = 0;
			for (j = sum_base; j < (sum_base+_BEYOND_REC_MAX); ++j)
			{
				if (touchpad_sum[j].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
				{
					touchpad_sum[j].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[j].driver = driver;
				touchpad_sum[j].sensor = sensor;
				touchpad_sum[j].beyond_type |= _BEYOND_MAX_LIMIT;
				touchpad_sum[j].raw_val = raw_buf[i];
				touchpad_sum[j].times = 1;
			}
			else
			{
				continue;
			}

			//GTP_DEBUG("[%d, %d]rawdata: %d, raw max limit: %d", driver, sensor, raw_buf[i], max_limit_value);
			//GTP_DEBUG("[%d, %d]rawdata: %d, raw max limit: %d", driver, sensor, raw_buf[i], gt6108_raw_acc_spec[i].max_rawdata);
			SET_INFO_LINE_INFO("[%s][%d, %d] rawdata: %d > raw max limit: %d", __FUNCTION__, driver, sensor, raw_buf[i], max_limit);
		}
	}
	return;
}

#if GTP_HAVE_TOUCH_KEY
/*
*********************************************************************************************************
* Function:
*	key rawdata max limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_key_max_test(u16 *raw_buf)
{
	u16 i = 0, j = 1, k = 0;
	u8 key_cnt = key_iso_pos[0];
	u8 driver, sensor;
	u8 sum_base = 2 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	driver = gt9xx_drv_num;
	for (i = gt9xx_sc_pxl_cnt; i < gt9xx_pixel_cnt; ++i)
	{
		sensor = (i%gt9xx_sen_num) + 1;
		if (key_is_isolated)
		{
			if ((key_iso_pos[j] != sensor) || (key_cnt == 0))
			{
				continue;
			}
			else	// only test key pixel rawdata
			{
				--key_cnt;
				++j;
			}
		}
		if (raw_buf[i] > max_limit_key)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_KEY_MAX_LMT;
			new_flag = 0;
			for (k = sum_base; k < (sum_base+_BEYOND_REC_MAX); ++k)
			{
				if (touchpad_sum[k].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if (touchpad_sum[k].sensor == sensor)
				{
					touchpad_sum[k].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[k].driver = driver;
				touchpad_sum[k].sensor = sensor;
				touchpad_sum[k].beyond_type |= _BEYOND_KEY_MAX_LMT;
				touchpad_sum[k].raw_val = raw_buf[i];
				touchpad_sum[k].times = 1;
				if (key_is_isolated)
				{
					touchpad_sum[k].key = j-1;
				}
			}
			else
			{
				continue;
			}
			SET_INFO_LINE_INFO("[%s][%d, %d] key rawdata: %d, key max limit: %d", __FUNCTION__, driver,sensor, raw_buf[i], max_limit_key);
		}
	}
	return;
}
/*
*********************************************************************************************************
* Function:
*	key rawdata min limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_key_min_test(u16 *raw_buf)
{
	u16 i = 0, j = 1, k = 0;
	u8 key_cnt = key_iso_pos[0];
	u8 driver, sensor;
	u8 sum_base = 3 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	driver = gt9xx_drv_num;
	for (i = gt9xx_sc_pxl_cnt; i < gt9xx_pixel_cnt; ++i)
	{
		sensor = (i%gt9xx_sen_num) + 1;
		if (key_is_isolated)
		{
			if ((key_iso_pos[j] != sensor) || (key_cnt == 0))
			{
				continue;
			}
			else	// only test key pixel rawdata
			{
				--key_cnt;
				++j;
			}
		}

		if (raw_buf[i] < min_limit_key)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_KEY_MIN_LMT;
			new_flag = 0;
			for (k = sum_base; k < (sum_base + _BEYOND_REC_MAX); ++k)
			{
				if (touchpad_sum[k].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if (sensor == touchpad_sum[k].sensor)
				{
					touchpad_sum[k].times++;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[k].driver = driver;
				touchpad_sum[k].sensor = sensor;
				touchpad_sum[k].beyond_type |= _BEYOND_KEY_MIN_LMT;
				touchpad_sum[k].raw_val = raw_buf[i];
				touchpad_sum[k].times = 1;
				if (key_is_isolated)
				{
					touchpad_sum[k].key = j-1;
				}
			}
			else
			{
				continue;
			}
			SET_INFO_LINE_INFO("[%s][%d, %d] key rawdata: %d, key min limit: %d", __FUNCTION__, driver, sensor, raw_buf[i], min_limit_key);
		}
	}
	return;
}
#endif

// add by leo for area accord check ++
/*
*********************************************************************************************************
* Function:
*	key rawdata area accord limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_acc_test(u16 *raw_buf)
{
	u16 i=0, j=0;
	u16 four_data[4]= {0}, acc_ans=0;
	u32 max_acc_data=0, min_acc_data=0;
	u8 driver=0, sensor=0;
	u8 sum_base = 3 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	//printk("////////////////////		gtp_raw_acc_test\n");

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		//get up/down/left/right data
		(i < gt9xx_drv_num) ? (four_data[0] = raw_buf[i]) : (four_data[0] = raw_buf[i - gt9xx_drv_num]);        //get  up
		(i >= (gt9xx_sc_pxl_cnt - gt9xx_drv_num)) ? (four_data[1] = raw_buf[i]) : (four_data[1] = raw_buf[i + gt9xx_drv_num]); //get down
		(((i + 1) % gt9xx_drv_num) == 0) ? (four_data[2] = raw_buf[i]) : (four_data[2] = raw_buf[i + 1]); //right
		((i % gt9xx_drv_num) == 0) ?  (four_data[3] = raw_buf[i]) : (four_data[3] = raw_buf[i - 1]);                       //left

		//find max, min
		(four_data[0] > four_data[1]) ? (max_acc_data = four_data[0], min_acc_data = four_data[1]) : (max_acc_data = four_data[1], min_acc_data = four_data[0]);
		(max_acc_data < four_data[2]) ? (max_acc_data = four_data[2]) : 0;
		(max_acc_data < four_data[3]) ? (max_acc_data = four_data[3]) : 0;
		(min_acc_data > four_data[2]) ? (min_acc_data = four_data[2]) : 0;
		(min_acc_data > four_data[3]) ? (min_acc_data = four_data[3]) : 0;

		//cal max, min
		max_acc_data = (raw_buf[i] > max_acc_data) ? (raw_buf[i] - max_acc_data): (max_acc_data - raw_buf[i]);
		max_acc_data = (max_acc_data * 1000)/raw_buf[i];

		min_acc_data = (raw_buf[i] > min_acc_data) ? (raw_buf[i] - min_acc_data): (min_acc_data - raw_buf[i]);
		min_acc_data = (min_acc_data * 1000)/raw_buf[i];

		//sel real max
		acc_ans = (max_acc_data > min_acc_data) ? max_acc_data: min_acc_data;

		gt6108_acc_data[i]=acc_ans;

		//compare
		if (gt6108_acc_data[i] > gt6108_raw_acc_spec[i].acc_data)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_MAX_LIMIT;
			driver = (i/gt9xx_sen_num) + 1;
			sensor = (i%gt9xx_sen_num) + 1;
			new_flag = 0;
			for (j = sum_base; j < (sum_base+_BEYOND_REC_MAX); ++j)
			{
				if (touchpad_sum[j].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
				{
					touchpad_sum[j].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[j].driver = driver;
				touchpad_sum[j].sensor = sensor;
				touchpad_sum[j].beyond_type |= _BEYOND_MAX_LIMIT;
				touchpad_sum[j].raw_val = raw_buf[i];
				touchpad_sum[j].times = 1;
			}
			else
			{
				continue;
			}
			SET_INFO_LINE_INFO("[%s][%d, %d] gt6108_acc_data[%d]: %d > gt6108_raw_acc_spec[%d].acc_data: %d", __FUNCTION__, driver, sensor, i, gt6108_acc_data[i], i, gt6108_raw_acc_spec[i].acc_data);
		}
	}
	return;
}
// add by leo for area accord check --

// add by leo for get raw data ++
s32 gt6108_get_raw_date(struct i2c_client * client, u16 *raw_buf, u16 *sample_buf)
{
	u16 i = 0, j = 0;
	s32 ret = 0; // SUCCESS, FAIL
	struct goodix_ts_data *ts;

	GTP_INFO("[%s]: start", __func__);

	ts = i2c_get_clientdata(i2c_connect_client);
	ret = gtp_wakeup_sleep(ts);
	gtp_irq_disable(ts);

	GTP_DEBUG("Parsing configuration...");
	ret = gtp_parse_config();
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("failed to parse config...");
		goto get_raw_data_exit;
	}

	GTP_DEBUG("Step 1: Send Rawdata Cmd");
	ts->gtp_rawdiff_mode = 1;
	ret = gt9_read_raw_cmd(client);
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("Send Read Rawdata Cmd failed!");
		goto get_raw_data_exit;
	}

	GTP_DEBUG("Step 2: Sample Rawdata");
	for (i = 0; i < 30; ++i)
	{
		GTP_INFO("sample time: %d", i);

		ret = gtp_read_rawdata(client, raw_buf);
		if (ret == FAIL)
		{
			SET_INFO_LINE_ERR("Read Rawdata failed!");
			goto get_raw_data_exit;
		}

		for(j=0; j<gt6108_channel_cnt; j++)
		{
			sample_buf[i*gt6108_channel_cnt+j] = raw_buf[j];
		}
	}
	gtp_i2c_end_cmd(client);

	ret = SUCCESS;
get_raw_data_exit:

	//add by leo for wait raw data ready timeout issue --
	gtp_send_cfg(client);
	msleep(300);
	//add by leo for wait raw data ready timeout issue --

	gtp_irq_enable(ts);
	ts->gtp_rawdiff_mode = 0;
	gt9_read_coor_cmd(client);
	return ret;
}
// add by leo for get raw data --

/*
*********************************************************************************************************
* Function:
*   gtp_raw_print
* Input:
*   u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_print(u16 *raw_buf)
{
	u16 i = 0;
	u16 min_val = 0, max_val = 0;
	u32 avg_val = 0;

	SET_INFO_LINE_INFO("Total node number: %d", gt9xx_sc_pxl_cnt);

	//print raw data
	min_val = raw_buf[0];
	max_val = raw_buf[0];

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		if(i%gt9xx_drv_num ==0)
		{
			if((i!=0)&&gt6108_debug)printk("\n");
			if(gt6108_debug)printk("S %2d: ", i/gt9xx_drv_num);
		}

		(raw_buf[i] > max_val) ? (max_val = raw_buf[i]): 0; //get max raw data
		(raw_buf[i] < min_val) ? (min_val = raw_buf[i]): 0; //get min raw data
		avg_val += raw_buf[i];

		gt6108_raw_data[i]=raw_buf[i];
		if(gt6108_debug)printk("%d ", raw_buf[i]);
	}
	if(gt6108_debug)printk("\n");

	//SET_INFO_LINE_INFO("Test Limit Rawdata Man:%d, Min:%d", test_parameter[gtp_test_sensor_id].max_limit_value, test_parameter[gtp_test_sensor_id].min_limit_value);
	SET_INFO_LINE_INFO("Last Frame Rawdata Max:%d, Min:%d, Avg:%d", max_val, min_val, (avg_val / gt9xx_sc_pxl_cnt));

	return;
}

/*
*********************************************************************************************************
* Function:
*	analyse rawdata retrived from ic registers
* Input:
*	u16 *raw_buf, buffer for rawdata,
*   u32 check_types, test items
* Return:
*	SUCCESS: test process succeed, FAIL: failed
*********************************************************************************************************
*/
static u32 gtp_raw_test(u16 *raw_buf, u32 check_types)
{
	if (raw_buf == NULL)
	{
		GTP_DEBUG("Invalid raw buffer pointer!");
		return FAIL;
	}
	if (0 == check_types)
	{
		check_types = default_test_types;
#if GTP_HAVE_TOUCH_KEY
		check_types |= _KEY_MAX_TEST | _KEY_MIN_TEST;
#endif
	}

	if(AreaAccordCheck) // add by leo for area accord check ++
	{
		if(check_types & _MAX_TEST)
		{
			gtp_raw_acc_test(raw_buf);
		}
	}
	else
	{
		if (check_types & _MAX_TEST)
		{
			gtp_raw_max_test(raw_buf);		// ?\C6\C1\D7\EE\B4\F3?\B2\E2\CA\D4
		}
		if (check_types & _MIN_TEST)
		{
			gtp_raw_min_test(raw_buf);		// ?\C6\C1\D7\EE?\B2\E2\CA\D4
		}

#if GTP_HAVE_TOUCH_KEY
		if (check_types & _KEY_MAX_TEST)
		{
			gtp_key_max_test(raw_buf);
		}
		if (check_types & _KEY_MIN_TEST)
		{
			gtp_key_min_test(raw_buf);
		}
#endif
	}
	return SUCCESS;
}

/*
====================================================================================================
* Function:
* 	output the test result
* Return:
* 	return the result. if result == 0, the TP is ok, otherwise list the beyonds
====================================================================================================
*/

static s32 gtp_get_test_result(void)
{
	u16 i = 0, j = 0;
	u16 beyond_max_num = 0;			// beyond max limit test times
	u16 beyond_min_num = 0;			// beyond min limit test times
#if GTP_HAVE_TOUCH_KEY
	u16 beyond_key_max = 0;			// beyond key max limit test times
	u16 beyond_key_min = 0;			// beyond key min limit test times
#endif
	s32 result = _CHANNEL_PASS;

#if GTP_DEBUG_ON
	for (i = 0; i < 4 * _BEYOND_REC_MAX; ++i)
	{
		printk("(%2d, %2d)[%2d] ", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		if (i && ((i+1) % 5 == 0))
		{
			printk("\n");
		}
	}
	printk("\n");
#endif

	for (i = 0; i < sample_set_num; ++i)
	{
		if (test_rslt_buf[i] & _BEYOND_MAX_LIMIT)
		{
			beyond_max_num++;
		}
		if (test_rslt_buf[i] & _BEYOND_MIN_LIMIT)
		{
			beyond_min_num++;
		}
#if GTP_HAVE_TOUCH_KEY
		if (test_rslt_buf[i] & _BEYOND_KEY_MAX_LMT)
		{
			beyond_key_max++;
		}
		if (test_rslt_buf[i] & _BEYOND_KEY_MIN_LMT)
		{
			beyond_key_min++;
		}
#endif
	}
	if (beyond_max_num > _MAX_ERROR_NUM)
	{
		result |= _BEYOND_MAX_LIMIT;
		j = 0;
		SET_INFO_LINE_INFO("Beyond Max Limit Points Info: ");
		for (i = 0; i < _BEYOND_REC_MAX; ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
	if (beyond_min_num > _MAX_ERROR_NUM)
	{
		result |= _BEYOND_MIN_LIMIT;
		SET_INFO_LINE_INFO("Beyond Min Limit Points Info:");
		j = 0;
		for (i = _BEYOND_REC_MAX; i < (2*_BEYOND_REC_MAX); ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
#if GTP_HAVE_TOUCH_KEY
	if (beyond_key_max > _MAX_ERROR_NUM)
	{
		result |= _BEYOND_KEY_MAX_LMT;
		SET_INFO_LINE_INFO("Beyond Key Max Limit Key Info:");
		for (i = 2*_BEYOND_REC_MAX; i < (3*_BEYOND_REC_MAX); ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
	if (beyond_key_min > _MAX_ERROR_NUM)
	{
		result |= _BEYOND_KEY_MIN_LMT;
		SET_INFO_LINE_INFO("Beyond Key Min Limit Key Info:");
		for (i = 3*_BEYOND_REC_MAX; i < (4*_BEYOND_REC_MAX); ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
#endif

	if (result == 0)
	{
		SET_INFO_LINE_INFO("[TEST SUCCEED]: The TP is ok!");
		test_result=SUCCESS; // add by leo for ATD
		return result;
	}
	SET_INFO_LINE_INFO("[TEST FAILED]:");
	test_result=FAIL; // add by leo for ATD
	if (result & _BEYOND_MAX_LIMIT)
	{
		SET_INFO_LINE_INFO("Beyond Raw Max Limit[Max Limit: %d]", max_limit_value);
	}
	if (result & _BEYOND_MIN_LIMIT)
	{
		SET_INFO_LINE_INFO("Beyond Raw Min Limit[Min Limit: %d]", min_limit_value);
	}
#if GTP_HAVE_TOUCH_KEY
	if (result & _BEYOND_KEY_MAX_LMT)
	{
		SET_INFO_LINE_INFO("Beyond KeyVal Max Limit[Key Max Limit: %d]", max_limit_key);
	}
	if (result & _BEYOND_KEY_MIN_LMT)
	{
		SET_INFO_LINE_INFO("Beyond KeyVal Min Limit[Key Min Limit: %d]", min_limit_key);
	}
#endif

	return result;
}

/*
 ===================================================
 * Function:
 * 		test gt9 series ic open test
 * Input:
 * 		client, i2c_client
 * Return:
 * 		SUCCESS: test process success, FAIL, test process failed
 *
 ===================================================
*/

s32 gt9xx_open_test(struct i2c_client * client)
{
	u16 i = 0;
	s32 ret = 0; // SUCCESS, FAIL
	struct goodix_ts_data *ts;
	u16 *raw_buf = NULL;

	ts = i2c_get_clientdata(i2c_connect_client);
	gtp_irq_disable(ts);
	SET_INFO_LINE_INFO("---gtp open test---");

	GTP_DEBUG("Parsing configuration...");
	ret = gtp_parse_config();
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("failed to parse config...");
		goto open_test_exit;
	}

	raw_buf = (u16*)kmalloc(sizeof(u16)* gt9xx_pixel_cnt, GFP_KERNEL);
	if (NULL == raw_buf)
	{
		SET_INFO_LINE_ERR("failed to allocate mem for raw_buf!");
		goto open_test_exit;
	}

	GTP_DEBUG("Step 1: Send Rawdata Cmd");

	ts->gtp_rawdiff_mode = 1;
	ret = gtp_raw_test_init(0);
	if (ret == FAIL) {
		SET_INFO_LINE_ERR("raw test init failed!");
		goto open_test_exit;
	}

	ret = gt9_read_raw_cmd(client);
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("Send Read Rawdata Cmd failed!");
		goto open_test_exit;
	}

	/* clear the first three sync pulse */
	for (i = 0; i < 3; i++) {
		int retry = 10;
		u8 state[3] = {(u8)(GTP_REG_RAW_READY>>8), (u8)GTP_REG_RAW_READY, 0};
		do {
			ret = gtp_i2c_read(client, &state[0], sizeof(state));
			if (ret <= 0 || (state[2] & 0x80) == 0x00){
				usleep_range(5000, 5050); /* 5ms */
				continue;
			}
			gtp_i2c_end_cmd(client);
			break;
		} while (retry--);
		if ((state[2] & 0x80) == 0x00) {
			GTP_INFO("Clear sync pulse %u timeout", i);
			break; /* timeout */
		}
	}

	GTP_DEBUG("Step 2: Sample Rawdata");
	// add by leo for dynamic change limit value ++
	max_limit_value = TotalMaxValue;
	min_limit_value = TotalMinValue;
	//gt6108_raw_acc_spec=&GuitarTestPlatformINI;
	for(i=0; i<TOTAL_PIXEL_NUM; i++)
	{
		gt6108_raw_acc_spec[i].node_number = GuitarTestPlatformINI[i*4];
		gt6108_raw_acc_spec[i].max_rawdata = GuitarTestPlatformINI[i*4+1];
		gt6108_raw_acc_spec[i].min_rawdata = GuitarTestPlatformINI[i*4+2];
		gt6108_raw_acc_spec[i].acc_data = GuitarTestPlatformINI[i*4+3];
	}
	/*
	for(i=0; i<TOTAL_PIXEL_NUM; i++)
	{
		if((i!=0)&&(i%32==0))
		{
			printk("\n");
		}
		printk("%d, %d, %d, %d ,", gt6108_raw_acc_spec[i].node_number, gt6108_raw_acc_spec[i].max_rawdata, gt6108_raw_acc_spec[i].min_rawdata, gt6108_raw_acc_spec[i].acc_data);
	}
	printk("\n");
	*/
	if((AbsoluteTotalCheck)&&(!AreaAccordCheck))
	{
		GTP_INFO("AbsoluteTotalCheck = %s, AreaAccordCheck = %s", (AbsoluteTotalCheck)?"true":"false", (AreaAccordCheck)?"true":"false");
		GTP_INFO("Open Test");
		GTP_INFO("Max Limit Value: %d", max_limit_value);
		GTP_INFO("Min Limit Value: %d", min_limit_value);
	}
	else if((!AbsoluteTotalCheck)&&(!AreaAccordCheck))
	{
		GTP_INFO("AbsoluteTotalCheck = %s, AreaAccordCheck = %s", (AbsoluteTotalCheck)?"true":"false", (AreaAccordCheck)?"true":"false");
		GTP_INFO("Open Test - compare single point by each Max & Min\n");
	}
	else
	{
		GTP_INFO("AbsoluteTotalCheck = %s, AreaAccordCheck = %s", (AbsoluteTotalCheck)?"true":"false", (AreaAccordCheck)?"true":"false");
		GTP_INFO("Area Accord Test\n");
	}
	// add by leo for dynamic change limit value --

	GTP_INFO("**Start to test TP, Please Do Not touch TP" );
	
	for (i = 0; i < sample_set_num; ++i)
	{
		GTP_DEBUG("sample time: %d", i);

		rslt_buf_idx = i;
		ret = gtp_read_rawdata(client, raw_buf);
		if (ret == FAIL)
		{
			SET_INFO_LINE_ERR("Read Rawdata failed!");
			goto open_test_exit;
		}

#if 0 /* print rawdata */
		// lonzo print rawdata +
		if (i < 16) {
			int j;

			printk("TAG-A: index:%d\n", i);
			printk("TAG-A: ");
			for(j = 0; j < gt9xx_sc_pxl_cnt; j++)
			{
				if((j != 0) && (j % gt9xx_drv_num ==0))
					printk("\nTAG-A: ");

				printk("%u ", raw_buf[j]);
			}
			printk("\n");
		}
		// print rawdata -
#endif
		ret = gtp_raw_test(raw_buf, 0);
		if (ret == FAIL)
		{
			gtp_i2c_end_cmd(client);
			continue;
		}
	}

	// add by leo for dump raw data ++
#if 0
	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		gt6108_raw_data[i]=raw_buf[i];
	}
#else
	gtp_raw_print(raw_buf); // add by leo only printf last raw data infor
#endif
	// add by leo for dump raw data --

	GTP_DEBUG("Step 3: Analyse Result");
	SET_INFO_LINE_INFO("Total %d Sample Data", sample_set_num);
	gtp_get_test_result();

	ret = SUCCESS;
open_test_exit:

	if (raw_buf)
		kfree(raw_buf);

	if (test_rslt_buf) {
		kfree(test_rslt_buf);
		test_rslt_buf = NULL;
	}

	if (touchpad_sum) {
		kfree(touchpad_sum);
		touchpad_sum = NULL;
	}

	if (gt6108_raw_acc_spec) {
		kfree(gt6108_raw_acc_spec); 
		gt6108_raw_acc_spec = NULL;
	}

	//add by leo for wait raw data ready timeout issue --
	//gtp_reset_guitar(client, 20);
	//msleep(100);
	gtp_send_cfg(client);
	msleep(300);
	//add by leo for wait raw data ready timeout issue --

	gtp_irq_enable(ts);
	ts->gtp_rawdiff_mode = 0;
	gt9_read_coor_cmd(client);	// back to read coordinates data
	SET_INFO_LINE_INFO("---gtp open test end---");
	gtp_i2c_write(ts->client, config, GTP_ADDR_LENGTH + GTP_CONFIG_MAX_LENGTH);
	return ret;
}

/*
 ===================================================
 * Function:
 *      test gt9 series ic disable
 * Input:
 *      client, i2c_client
 * Return:
 *      SUCCESS: test process success, FAIL, test process failed
 *
 ===================================================
*/
void gt9xx_tp_disable(struct i2c_client *client)
{
	s8 ret = -1;
	u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(client);

	//gtp_irq_disable(ts);
	//disable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 1;     // suspend esd
#endif

	//enter sleep
	GTP_GPIO_OUTPUT(ts->pdata->irq_gpio, 0);
	msleep(5);

	ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
	if (ret > 0)
	{
		GTP_INFO("GTP enter sleep!");
	}
	else
	{
		GTP_ERROR("GTP send sleep cmd failed.");
		return;
	}
	SET_INFO_LINE_INFO("---gtp enter sleep---");

	//gtp_irq_enable(ts);
	//enable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	//ts->gtp_is_suspend = 0; 	// resume esd, due to into sleep can't response ESD ask
#endif

	return;
}

/*
 ===================================================
 * Function:
 *      test gt9 series ic enable
 * Input:
 *      client, i2c_client
 * Return:
 *      SUCCESS: test process success, FAIL, test process failed
 *
 ===================================================
*/
void gt9xx_tp_enable(struct i2c_client * client)
{
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(client);

	//gtp_irq_disable(ts);
	//disable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	//ts->gtp_is_suspend = 1;     // suspend esd
#endif

	//wakeup or reset gtp
	//gtp_wakeup_sleep(ts);	//wakeup
	gtp_reset_guitar(ts->client, 50);	//add by one
	SET_INFO_LINE_INFO("---gtp restart---");

	//gtp_irq_enable(ts);
	//enable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 0; 	// resume esd
#endif

	return;
}

static ssize_t gtp_sysfs_shorttest_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	u8 index;
	u32 len;
	int ret=0;
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(i2c_connect_client);

	ret = gtp_wakeup_sleep(ts);
	gtp_irq_disable(ts);

	gt9xx_short_test(i2c_connect_client);

	gtp_irq_enable(ts);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}

static ssize_t gtp_sysfs_shorttest_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}

static ssize_t gtp_sysfs_opentest_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	s32 index;
	u32 len;
	int ret=0;
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(i2c_connect_client);

	ret = gtp_wakeup_sleep(ts);
	gtp_irq_disable(ts);

	gt9xx_open_test(i2c_connect_client);

	gtp_irq_enable(ts);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}

static ssize_t gtp_sysfs_opentest_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}

static DEVICE_ATTR(shorttest, S_IRUGO|S_IWUSR, gtp_sysfs_shorttest_show, gtp_sysfs_shorttest_store);
static DEVICE_ATTR(opentest, S_IRUGO|S_IWUSR, gtp_sysfs_opentest_show, gtp_sysfs_opentest_store);

// add by leo for dynamic change limit value ++
static ssize_t gtp_sysfs_tp_enable_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	s32 index;
	ssize_t len;

	gt9xx_tp_enable(i2c_connect_client);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}
static ssize_t gtp_sysfs_tp_enable_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}
static DEVICE_ATTR(tp_enable, S_IRUGO|S_IWUSR, gtp_sysfs_tp_enable_show, gtp_sysfs_tp_enable_store);

static ssize_t gtp_sysfs_tp_disable_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	s32 index;
	ssize_t len;

	gt9xx_tp_disable(i2c_connect_client);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}
static ssize_t gtp_sysfs_tp_disable_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}
static DEVICE_ATTR(tp_disable, S_IRUGO|S_IWUSR, gtp_sysfs_tp_disable_show, gtp_sysfs_tp_disable_store);

static ssize_t gt6108_change_range_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	return sprintf(buf,"TotalMaxValue = %d, TotalMinValue = %d\n", TotalMaxValue, TotalMinValue);
}

static ssize_t gt6108_change_range_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	int Max = 0, Min = 0;
	sscanf (buf, "%d %d", &Max, &Min);
	TotalMaxValue = Max;
	TotalMinValue = Min;

	printk("%s:[%d]: set TotalMaxValue = %d, TotalMinValue =%d\n", __func__, __LINE__,TotalMaxValue,TotalMinValue);

	return count;
}
static DEVICE_ATTR(gt6108_limit, (S_IWUSR|S_IRUGO), gt6108_change_range_show, gt6108_change_range_store);

static ssize_t gt6108_threshold_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	return sprintf(buf,"gt900_short_threshold = %d\ngt900_resistor_threshold = %d\ngt900_resistor_warn_threshold = %d\ngt900_gnd_resistor_threshold = %d\ngt900_adc_read_delay = %d\ngt900_diffcode_short_threshold = %d\n",
	               gt900_short_threshold, gt900_resistor_threshold, gt900_resistor_warn_threshold, gt900_gnd_resistor_threshold, gt900_adc_read_delay, gt900_diffcode_short_threshold);
}

static ssize_t gt6108_threshold_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	int short_threshold=0,resistor_threshold=0,resistor_warn_threshold=0,gnd_resistor_threshold=0,adc_read_delay=0,diffcode_short_threshold=0;

	sscanf (buf, "%d %d %d %d %d %d", &short_threshold, &resistor_threshold, &resistor_warn_threshold,
	        &gnd_resistor_threshold, &adc_read_delay, &diffcode_short_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,short_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,resistor_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,resistor_warn_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,gnd_resistor_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,adc_read_delay);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,diffcode_short_threshold);

	gt900_short_threshold=short_threshold;
	gt900_resistor_threshold=resistor_threshold;
	gt900_resistor_warn_threshold=resistor_warn_threshold;
	gt900_gnd_resistor_threshold=gnd_resistor_threshold;
	gt900_adc_read_delay=adc_read_delay;
	gt900_diffcode_short_threshold=diffcode_short_threshold;

	return count;
}
static DEVICE_ATTR(gt6108_thd, (S_IWUSR|S_IRUGO), gt6108_threshold_show, gt6108_threshold_store);
// add by leo for dynamic change limit value --

/*******************************************************
Description:
	Goodix debug sysfs init function.

Parameter:
	none.

return:
	Executive outcomes. 0---succeed.
*******************************************************/
s32 gtp_test_sysfs_init(void)
{
	s32 ret ;
	//int i = 0;
	//struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);

	// add by leo for different TP source --
	#if 0
	if((ts->TP_ID == 0)||(ts->TP_ID == 1))
	{
		TotalMaxValue = TotalMaxValue_GIS;
		TotalMinValue = TotalMinValue_GIS;

		GTP_INFO("%s: GIS TP use GuitarTestPlatformINI_GIS", __func__);
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			GuitarTestPlatformINI[i]=GuitarTestPlatformINI_GIS[i];
		}
	}
	else if((ts->TP_ID == 2)||(ts->TP_ID == 3))
	{
		TotalMaxValue = TotalMaxValue_TopTouch;
		TotalMinValue = TotalMinValue_TopTouch;

		GTP_INFO("%s: TopTouch TP use GuitarTestPlatformINI_TOPTOUCH", __func__);
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			GuitarTestPlatformINI[i]=GuitarTestPlatformINI_TOPTOUCH[i];
		}
	}
	else
	{
		TotalMaxValue = TotalMaxValue_GIS;
		TotalMinValue = TotalMinValue_GIS;

		GTP_ERROR("%s: Unknow TP use default GuitarTestPlatformINI_GIS", __func__);
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			GuitarTestPlatformINI[i]=GuitarTestPlatformINI_GIS[i];
		}
	}
	#endif
	// add by leo for different TP source --

	goodix_debug_kobj = kobject_create_and_add("gtp_test", NULL) ;
	SET_INFO_LINE_INFO("Starting initlizing gtp_debug_sysfs");
	if (goodix_debug_kobj == NULL)
	{
		GTP_ERROR("%s: subsystem_register failed\n", __func__);
		return -ENOMEM;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_shorttest.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create shorttest file failed\n", __func__);
		return ret;
	}
	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_opentest.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create opentes file failed\n", __func__);
		return ret;
	}

	// add by leo for dynamic change limit value ++
	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_tp_disable.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
		return ret;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_tp_enable.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
		return ret;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_gt6108_limit.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create gt6108_limit file failed\n", __func__);
		return ret;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_gt6108_thd.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create gt6108_threshold file failed\n", __func__);
		return ret;
	}
	// add by leo for dynamic change limit value --

	GTP_INFO("Goodix debug sysfs create success!");
	return 0 ;
}

void gtp_test_sysfs_deinit(void)
{
	sysfs_remove_file(goodix_debug_kobj, &dev_attr_shorttest.attr);
	sysfs_remove_file(goodix_debug_kobj, &dev_attr_opentest.attr);
	kobject_del(goodix_debug_kobj);

	return;
}

// add by leo for dump raw data ++
static int gt6108_reload_test_matrix(void)
{
	int i=0, j=1, k=0, len=0, begin=1, end=0, num=0, x=1;
	struct file *filp=NULL;
	mm_segment_t old_fs;
	u8 *temp=NULL;
	u16 *raw_acc_info=NULL;

	// 767,xxxx,xxxx,xxx,
	temp = (u8*)kmalloc(sizeof(u8)* gt9xx_sc_pxl_cnt*18, GFP_KERNEL);
	if (!temp)
		return -ENOMEM;

	raw_acc_info = (u16*)kmalloc(sizeof(u16)* gt9xx_sc_pxl_cnt*18, GFP_KERNEL);
	if (!raw_acc_info) {
		kfree(temp);
		return -ENOMEM;
	}

	memset(temp, 0, sizeof(u8)* gt9xx_sc_pxl_cnt*18);
	memset(raw_acc_info, 0, sizeof(u16)* gt9xx_sc_pxl_cnt*18);

	filp=filp_open(TEST_CONFIG_FILE_PATH,O_RDWR|O_CREAT,S_IRWXU|S_IRWXG|S_IRWXO);
	if (IS_ERR_OR_NULL(filp))
	{
		printk("%s:[%d]: TEST_CONFIG_FILE_PATH Open Failed \n",__FUNCTION__, __LINE__);
		return -ENOENT;
	}

	if(filp->f_op != NULL && filp->f_op->read != NULL)
	{
		old_fs = get_fs();
		set_fs(KERNEL_DS);

		len = filp->f_op->read(filp, temp, gt9xx_sc_pxl_cnt*18, &filp->f_pos);
		//gt6108_raw_acc_spec=&temp;
		set_fs(old_fs);
	}

	printk("%s:[%d]: len=%d\n",__FUNCTION__, __LINE__,len);
	filp_close(filp,NULL);

	raw_acc_info[0]=temp[0]-48;
	for(i=2; i<len; i++)
	{
		//printk("%d\n",i);
		x=1;
		if(temp[i]==',')
		{
			end=begin;
			begin=i;
			num=(begin-end)-1;

			//printk("%s:[%d]: end=%d, begin=%d, num=%d\n",__FUNCTION__, __LINE__,end,begin,num);
			for(k=num; k>0; k--)
			{
				//printk("%s:[%d]: raw_acc_info[%d]=%d\n",__FUNCTION__, __LINE__,j,temp[end+k]-48);
				//printk("%s:[%d]: raw_acc_info[%d]=%d\n",__FUNCTION__, __LINE__,j,(temp[end+k]-48)*x);
				raw_acc_info[j]+=(temp[end+k]-48)*x;
				x*=10;
			}
			//printk("%s:[%d]: end=%d, begin=%d, num=%d, raw_acc_info[%d]=%d\n",__FUNCTION__, __LINE__,end,begin,num,j,raw_acc_info[j]);
			j++;
		}
	}

	for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
	{
		if((i!=0)&&(i%32==0))
		{
			printk("\n");
		}
		GuitarTestPlatformINI[i]=raw_acc_info[i];
		printk("%d ",GuitarTestPlatformINI[i]);
	}
	printk("\n");

	kfree(temp);
	kfree(raw_acc_info);
	return 0;
}

static int gt6108_proc_test_read(struct seq_file *buf, void *v)
{
	//int i=0;

	seq_printf(buf, "%s\n\n",(test_result==SUCCESS)?"PASS":"FAIL");

	return 0;
}

static ssize_t gt6108_proc_test_write(struct file *filp, const char __user *buf, size_t len, loff_t *data)
{
	if(buf[0] == 't') // total opentest
	{
		printk("%s:[%d]: Total Max and Min Open Test \n", __func__, __LINE__);
		AreaAccordCheck=false;
		AbsoluteTotalCheck=true;

		printk("%s:[%d]: AbsoluteTotalCheck = %s, TotalMaxValue = %d, TotalMinValue = %d \n", __func__, __LINE__
		       ,(AbsoluteTotalCheck)?"true":"false",TotalMaxValue,TotalMinValue);
	}
	if(buf[0] == 's') // single point opentest
	{
		printk("%s:[%d]: Single Max and Min Open Test \n", __func__, __LINE__);
		AreaAccordCheck=false;
		AbsoluteTotalCheck=false;

		printk("%s:[%d]: AbsoluteTotalCheck = %s \n", __func__, __LINE__
		       ,(AbsoluteTotalCheck)?"true":"false");
	}
	if(buf[0] == 'a') // single Area Accord Check
	{
		printk("%s:[%d]: Area Accored Test \n", __func__, __LINE__);
		AreaAccordCheck=true;

		printk("%s:[%d]: AreaAccordCheck = %s \n", __func__, __LINE__
		       ,(AreaAccordCheck)?"true":"false");
	}

	if((buf[0] == 'r')&&(buf[1] == 'e')&&(buf[2] == 'l')&&(buf[3] == 'o')&&(buf[4] == 'a')&&(buf[5] == 'd'))
	{
		printk("%s:[%d]: reloade Guitar Test Platform ini data !\n", __func__, __LINE__);
		gt6108_reload_test_matrix();
	}

	return len;
}

static int gt6108_proc_test_open(struct inode *inode, struct  file *file)
{
	return single_open(file, gt6108_proc_test_read, NULL);
}

static const struct file_operations gt6108_test_fops =
{
	.owner = THIS_MODULE,
	.open = gt6108_proc_test_open,
	.read = seq_read,
	.write = gt6108_proc_test_write,
};

void gt6108_create_proc_test_file(void)
{
	gt6108_proc_test_file = proc_create(GT6108_PROC_TEST_FILE, 0666, NULL, &gt6108_test_fops);
	if(gt6108_proc_test_file)
	{
		GTP_INFO("%s:[%d]: proc test file create sucessed!", __func__, __LINE__);
	}
	else
	{
		GTP_ERROR("%s:[%d]: proc test file create failed!", __func__, __LINE__);
	}

	return;
}

void gt6108_remove_proc_test_file(void)
{
	extern struct proc_dir_entry proc_root;
	printk("%s:[%d]: proc test file removed\n", __func__, __LINE__);
	remove_proc_entry(GT6108_PROC_TEST_FILE, &proc_root);

	return;
}

static int gt6108_proc_diag_read(struct seq_file *buf, void *v)
{
	int i=0;

	// Raw Data
	seq_printf(buf, "Raw Data[%d]:\n", gt9xx_sc_pxl_cnt);
	for(i=0; i<gt9xx_sc_pxl_cnt; i++)
	{
		if((i!=0)&&(i%gt9xx_drv_num==0))
		{
			//printk("\n");
			seq_printf(buf, "\n");
		}
		//printk("%d ",gt6108_raw_data[i]);
		seq_printf(buf, "%d ",gt6108_raw_data[i]);
	}
	//printk("\n");
	seq_printf(buf, "\n");

	//printk("\n\n");
	seq_printf(buf, "\n");

	// Area Accord Data
	if(AreaAccordCheck)
	{
		seq_printf(buf, "Area Accord Data[%d]:\n", gt9xx_sc_pxl_cnt);
		for(i=0; i<gt9xx_sc_pxl_cnt; i++)
		{
			if((i!=0)&&(i%gt9xx_drv_num==0))
			{
				//printk("\n");
				seq_printf(buf, "\n");
			}
			//printk("%04d ",gt6108_acc_data[i]);
			seq_printf(buf, "%04d ",gt6108_acc_data[i]);
		}
		//printk("\n");
		seq_printf(buf, "\n");

		//printk("\n\n");
		seq_printf(buf, "\n");
	}

	// Guitar Test Platform Data
	if((!AbsoluteTotalCheck)||AreaAccordCheck)
	{
		seq_printf(buf, "Guitar Test Platform INI Data[%d]:\n", (int)(sizeof(GuitarTestPlatformINI)/sizeof(u16)));
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			if((i!=0)&&(i%gt9xx_drv_num==0))
			{
				//printk("\n");
				seq_printf(buf, "\n");
			}
			//printk("%d ",GuitarTestPlatformINI[i]);
			seq_printf(buf, "%d ",GuitarTestPlatformINI[i]);
		}
		//printk("\n");
		seq_printf(buf, "\n");

		//printk("\n\n");
		seq_printf(buf, "\n");
	}
	return 0;
}

static ssize_t gt6108_proc_diag_write(struct file *filp, const char __user *buf, size_t len, loff_t *data)
{
	return len;
}

static int gt6108_proc_diag_open(struct inode *inode, struct  file *file)
{
	return single_open(file, gt6108_proc_diag_read, NULL);
}

static const struct file_operations gt6108_diag_fops =
{
	.owner = THIS_MODULE,
	.open = gt6108_proc_diag_open,
	.read = seq_read,
	.write = gt6108_proc_diag_write,
};

void gt6108_create_proc_diag_file(void)
{
	gt6108_proc_diag_file = proc_create(GT6108_PROC_DIAG_FILE, 0666, NULL, &gt6108_diag_fops);
	if(gt6108_proc_diag_file)
	{
		GTP_INFO("%s:[%d]: proc diag file create sucessed!", __func__, __LINE__);
	}
	else
	{
		GTP_ERROR("%s:[%d]: proc diag file create failed!", __func__, __LINE__);
	}

	return;
}

void gt6108_remove_proc_diag_file(void)
{
	extern struct proc_dir_entry proc_root;
	GTP_INFO("%s:[%d]: proc diag file removed", __func__, __LINE__);
	remove_proc_entry(GT6108_PROC_DIAG_FILE, &proc_root);

	return;
}
// add by leo for dump raw data --
